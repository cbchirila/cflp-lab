<!DOCTYPE html>
<html lang="ro">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<body>
    <h1>4.Programarea orientată pe obiecte</h1>


    <h2>4.1 Prezentare generală a claselor, structurilor și înregistrărilor în C#</h2>
    <p>În C#, definiția unui tip - o clasă, o structură sau o înr egistrare - este asemenea unui plan(machetă) care
        specifică ce poate face tipul respectiv. Un obiect este în esență un bloc de memorie care a fost alocat și
        configurat conform planului.Acest articol oferă o prezentare generală a acestor machete și caracteristicile lor.
        Următorul articol din această serie introduce obiectele.</p>


    <h2>4.1.1 Încapsularea</h2>
    <p>Încapsularea este uneori numită prima piatră de temelie sau principiu al programării orientate pe obiect. O clasă
        sau structură poate specifica gradul de accesibilitate al fiecărui membru al său în codul din afara clasei sau
        structurii. Metodele și variabilele care nu sunt destinate să fie utilizate din afara clasei sau asamblării pot
        fi ascunse pentru a limita potențialul de erori de cod sau exploatare malitioasă. Pentru mai multe informații,
        consultați tutorialul de programare orientată pe obiect.</p>


    <h2>4.1.2 Membri</h2>
    <p>Membrii unui tip includ toate metodele, câmpurile, constantele, proprietățile și evenimentele. În C#, nu există
        variabile sau metode globale, așa cum există în alte limbaje. Chiar și punctul de intrare al unui program,
        metoda Main, trebuie să fie declarat în cadrul unei clase sau structuri (implicit atunci când utilizați
        declarații de nivel superior).</p>

    <p>Următoarea listă include toate tipurile de membri care pot fi declarați într-o clasă, structură sau înregistrare:
    </p>
    <ul>
        <li>Câmpuri</li>
        <li>Constante</li>
        <li>Proprietăți</li>
        <li>Metode</li>
        <li>Constructori</li>
        <li>Evenimente</li>
        <li>Finalizatori</li>
        <li>Indexatori</li>
        <li>Operatori</li>
        <li>Tipuri imbricate</li>
    </ul>
    <p>Pentru mai multe informații, consultați secțiunea Membri.</p>


    <h2>4.1.3 Accesibilitate</h2>
    <p>Unele metode și proprietăți sunt destinate să fie apelate sau accesate din codul din afara unei clase sau
        structuri, cunoscut precum un cod client. Alte metode și proprietăți pot fi folosite doar în interiorul clasei
        sau structurii în sine. Este important să limitați accesibilitatea codului dvs. astfel încât să poată fi accesat
        doar de codul client intenționat. Specificați gradul de accesibilitate al tipurilor și membrilor lor față de
        codul client utilizând următoarele modificatori de acces:</p>
    <ul>
        <li>public</li>
        <li>protected</li>
        <li>internal</li>
        <li>protected internal</li>
        <li>private</li>
        <li>private protected</li>
    </ul>
    <p>Accesibilitatea implicită este privată.</p>


    <h2>4.1.4 Moștenire</h2>
    <p>Clasele (dar nu și structurile) suportă conceptul de moștenire. O clasă care derivă dintr-o altă clasă, numită
        clasă de bază, conține automat toți membrii publici, protejați și interni ai clasei de bază, cu excepția
        constructorilor și finalizatorilor săi.</p>
    <p>Clasele pot fi declarate ca abstracte, ceea ce înseamnă că una sau mai multe dintre metodele lor nu au o
        implementare. Cu toate că, clasele abstracte nu pot fi instanțiate direct, ele pot servi precum clase de bază
        pentru alte clase care furnizează implementarea lipsă. Clasele pot fi, de asemenea, declarate ca sigilate
        (sealed) pentru a preveni moștenirea din partea altor clase.</p>
    <p>Pentru mai multe informații, consultați articolele "Moștenire" și "Polimorfism".</p>


    <h2>4.1.5 Interfețe</h2>
    <p>Clasele, structurile și înregistrările pot implementa mai multe interfețe. A implementa o interfață înseamnă că
        tipul implementează toate metodele definite în interfață. Pentru mai multe informații, consultați articolul
        "Interfețe".</p>


    <h2>4.1.6 Tipuri generice</h2>
    <p>Clasele, structurile și înregistrările pot fi definite cu unul sau mai mulți parametri de tip. Codul client
        furnizează tipul la crearea unei instanțe a tipului. De exemplu, clasa List< T> din namespace-ul
            System.Collections.Generic este definită cu un parametru de tip. Codul client creează o instanță de List<
                string> sau List< int>pentru a specifica tipul de date pe care lista îl va conține. Pentru mai multe
                    informații, consultați articolul "Generice".</p>


    <h2>4.1.7 Tipuri statice</h2>
    <p>Clasele (dar nu și structurile sau înregistrările) pot fi declarate ca fiind statice. O clasă statică poate
        conține numai membri statici și nu poate fi instanțiată folosind cuvântul cheie "new". O singură copie a clasei
        este încărcată în memorie la încărcarea programului, iar membrii săi sunt accesați folosind numele clasei.
        Clasele, structurile și înregistrările pot conține membri statici. Pentru mai multe informații, consultați
        articolele "Clase statice și membri statici de clasă".</p>


    <h2>4.1.8 Tipuri imbricate</h2>
    <p>O clasă, structură sau înregistrare poate fi imbricată într-o altă clasă, structură sau înregistrare. Pentru mai
        multe informații, consultați articolul "Tipuri imbricate".</p>


    <h2>4.1.9 Tipuri parțiale</h2>
    <p>Puteți defini o parte a unei clase, structuri sau metode într-un fișier de cod și o altă parte într-un fișier de
        cod separat. Pentru mai multe informații, consultați articolul "Clase și metode parțiale".</p>


    <h2>4.1.10 Inițializatoare de obiecte</h2>
    <p>Puteți instantia și inițializa obiecte de tip clasă sau structură, precum și colecții de obiecte, prin atribuirea
        de valori la proprietățile acestora. Pentru mai multe informații, consultați articolul "Cum să inițializați
        obiecte folosind un inițializator de obiecte".</p>


    <h2>4.1.11 Tipuri anonime</h2>
    <p>În situații în care nu este convenabil sau necesar să creați o clasă numită, puteți folosi tipurile anonime.
        Tipurile anonime sunt definite de membrii lor de date numiți. Pentru mai multe informații, consultați articolul
        "Tipuri anonime".</p>


    <h2>4.1.12 Metode de extensie</h2>
    <p>Puteți "extinde" o clasă fără a crea o clasă derivată, creând un tip separat. Acest tip conține metode care pot
        fi apelate ca și cum ar aparține tipului original. Pentru mai multe informații, consultați articolul "Metode de
        extensie".</p>


    <h2>4.1.13 Variabile locale cu tip implicit</h2>
    <p>În cadrul unei metode a unei clase sau structuri, puteți folosi tipizarea implicită pentru a instrui compilatorul
        să determine tipul unei variabile la momentul compilării. Pentru mai multe informații, consultați articolul "var
        (referință C#)".</p>

    <h2>4.1.14 Înregistrări</h2>
    <p>În C# 9 este introdus tipul de date "înregistrare"(record), un tip de referință pe care îl puteți crea în locul
        unei clase sau a unei structuri. Înregistrările sunt clase cu comportament încorporat pentru încapsularea
        datelor în tipuri de date imutabile. C# 10 introduce, de asemenea, tipul de date "record struct" ca tip de
        valoare. O înregistrare(fie că este o clasă de tip înregistrare sau o structură de tip înregistrare) furnizează
        următoarele caracteristici:</p>
    <ul>
        <li>Sintaxă concisă pentru crearea unui tip de referință cu proprietăți imutabile.</li>
        <li>Egalitate de valoare. Două variabile de tip înregistrare sunt egale dacă au același tip și dacă, pentru
            fiecare câmp, valorile din ambele înregistrări sunt egale. Clasele utilizează egalitatea de referință: două
            variabile de tip clasă sunt egale dacă se referă la același obiect.</li>
        <li>Sintaxă concisă pentru mutarea non-distructivă. O expresie "with" vă permite să creați o nouă instanță de
            înregistrare care este o copie a unei instanțe existente, dar cu valorile proprietăților specificate
            schimbate.
        </li>
        <li>Formatare încorporată pentru afișare. Metoda ToString afișează numele tipului de înregistrare și numele și
            valorile proprietăților publice.</li>
        <li>Suport pentru ierarhiile de moștenire în clasele de înregistrare. Clasele de înregistrare suportă
            moștenirea. Structurile de înregistrare nu suportă moștenirea.</li>
    </ul>
    <p>Pentru mai multe informații, consultați secțiunea "Înregistrări."</p>


    <h2>4.1.15 Specificația limbajului C#</h2>
    <p>Pentru mai multe informații, consultați Specificația limbajului C#. Specificația limbajului este sursa definitivă
        pentru sintaxa și utilizarea limbajului C#.</p>


    <h1>4.2 Obiecte</h1>
    <h2>4.2.1 Obiecte - crearea de instanțe ale tipurilor</h2>
    <p>Definiția unei clase sau structuri este similară cu un plan detaliat care specifică ce poate face tipul
        respectiv. Un obiect este, în esență, un bloc de memorie alocat și configurat conform planului. Un program poate
        crea multe obiecte ale aceleiași clase. Obiectele sunt numite și instanțe și pot fi stocate fie într-o variabilă
        cu nume, fie într-un array sau colecție. Codul client este codul care utilizează aceste variabile pentru a apela
        metodele și accesa proprietățile publice ale obiectului. Într-un limbaj orientat pe obiect, precum C#, un
        program tipic constă în interacțiunea dinamică a mai multor obiecte.</p>
    <h3>Notă:</h3>
    <strong>Tipurile statice se comportă diferit față de ceea ce este descris aici. Pentru mai multe informații,
        consultați "Clasele Statice" și "Membrii de Clasă Statici."</strong>

    <h2>4.2.2 Instanțele structurilor vs. instanțele claselor</h2>
    <p>Deoarece clasele sunt tipuri de referință, o variabilă de obiect de clasă ține o referință către adresa
        obiectului din heap-ul gestionat. Dacă o a doua variabilă de același tip este asignată primei variabile, atunci
        ambele variabile referă același obiect la acea adresă. Această situație este discutată în detaliu ulterior în
        acest articol.</p>
    <p>Instanțele claselor sunt create folosind operatorul new. În exemplul următor, Person este tipul, iar person1 și
        person2 sunt instanțe sau obiecte ale acelui tip.</p>
    <pre>
    <code>
        public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
    public Person(string name, int age)
    {
        Name = name;
        Age = age;
    }
    // Alte proprietăți, metode și evenimente...
}

class Program
{
    static void Main()
    {
        Person person1 = new Person("Leopold", 6);
        Console.WriteLine("person1 Name = {0} Age = {1}", person1.Name, person1.Age);

        // Declarați o nouă variabilă de tipul Person și atribuiți-i valoarea variabilei person1.
        Person person2 = person1;

        //Dacă schimbați numele variabilei person2, atunci numele variabilei person1 se va schimba.
        person2.Name = "Molly";
        person2.Age = 16;

        Console.WriteLine("person2 Name = {0} Age = {1}", person2.Name, person2.Age);
        Console.WriteLine("person1 Name = {0} Age = {1}", person1.Name, person1.Age);
    }
}
/*
    Output:
    person1 Name = Leopold Age = 6
    person2 Name = Molly Age = 16
    person1 Name = Molly Age = 16
*/
    </code>
</pre>
    <p>Deoarece structurile sunt tipuri de valoare, o variabilă de obiect de structură ține o copie a întregului obiect.
        Instanțele de structuri pot fi create, de asemenea, folosind operatorul new, dar acest lucru nu este
        obligatoriu, așa cum este ilustrat în exemplul următor:</p>
    <pre>
    <code>
        namespace Example;

public struct Person
{
    public string Name;
    public int Age;
    public Person(string name, int age)
    {
        Name = name;
        Age = age;
    }
}

public class Application
{
    static void Main()
    {
        // Create  struct instance and initialize by using "new".
        // Memory is allocated on thread stack.
        Person p1 = new Person("Alex", 9);
        Console.WriteLine("p1 Name = {0} Age = {1}", p1.Name, p1.Age);

        // Create  new struct object. Note that  struct can be initialized
        // without using "new".
        Person p2 = p1;

        // Assign values to p2 members.
        p2.Name = "Spencer";
        p2.Age = 7;
        Console.WriteLine("p2 Name = {0} Age = {1}", p2.Name, p2.Age);

        // p1 values remain unchanged because p2 is  copy.
        Console.WriteLine("p1 Name = {0} Age = {1}", p1.Name, p1.Age);
    }
}
/*
    Output:
    p1 Name = Alex Age = 9
    p2 Name = Spencer Age = 7
    p1 Name = Alex Age = 9
*/
    </code>
</pre>
    <p>Memoria pentru ambele p1 și p2 este alocată pe stiva firului de execuție. Această memorie este recuperată odată
        cu tipul sau metoda în care este declarată. Acesta este unul dintre motivele pentru care structurile sunt
        copiate la asignare. În schimb, memoria alocată pentru o instanță de clasă este recuperată automat (colectată de
        gunoi) de către runtime-ul limbajului comun atunci când toate referințele la obiect sunt ieșite din domeniul de
        vizibilitate (out of scope). Nu este posibil să distrugeți un obiect de clasă într-un mod determinist, așa cum
        se poate în C++. Pentru mai multe informații despre colectarea de gunoi (garbage collection) în .NET, consultați
        Colectarea de gunoi (Garbage Collection).</p>
    <h3>Notă:</h3>
    <strong>
        Alocarea și dealocarea memoriei pe heap-ul gestionat este optimizată în mod semnificativ în runtime-ul
        limbajului comun. În majoritatea cazurilor, nu există diferențe semnificative în costul de performanță între
        alocarea unei instanțe de clasă pe heap și alocarea unei instanțe de structură pe stivă.</strong>


    <h2>4.2.3 Identitatea obiectului vs. Egalitatea valorii</h2>
    <p>Atunci când comparați două obiecte pentru egalitate, trebuie mai întâi să faceți distincția între faptul dacă
        doriți să știți dacă cele două variabile reprezintă același obiect în memorie, sau dacă valorile unuia sau mai
        multor câmpuri ale lor sunt echivalente. Dacă intenționați să comparați valorile, trebuie să luați în
        considerare dacă obiectele sunt instanțe ale tipurilor de valoare (structuri) sau ale tipurilor de referință
        (clase, delegați, tablouri).</p>
    <ul>
        <li>Pentru a determina dacă două instanțe de clasă se referă la aceeași locație în memorie (ceea ce înseamnă că
            au aceeași identitate), utilizați metoda statică Object.Equals. (System.Object este clasa de bază implicită
            pentru toate tipurile de valoare și tipurile de referință, inclusiv structurile și clasele definite de
            utilizator.)</li>
        <li>Pentru a determina dacă câmpurile de instanță în două instanțe de structură au aceleași valori, utilizați
            metoda ValueType.Equals. Deoarece toate structurile moștenesc implicit din System.ValueType, apelați direct
            metoda pe obiectul dvs., așa cum este prezentat în exemplul următor:
            <pre>
            <code>
                // Person is defined in the previous example.

//public struct Person
//{
//    public string Name;
//    public int Age;
//    public Person(string name, int age)
//    {
//        Name = name;
//        Age = age;
//    }
//}

Person p1 = new Person("Wallace", 75);
Person p2 = new Person("", 42);
p2.Name = "Wallace";
p2.Age = 75;

if (p2.Equals(p1))
    Console.WriteLine("p2 and p1 have the same values.");

// Output: p2 and p1 have the same values.
            </code>
        </pre>
            Implementarea Equals din System.ValueType utilizează împachetarea și reflectarea în anumite cazuri. Pentru
            informații despre cum să furnizați un algoritm de egalitate eficient specific tipului dvs., consultați "Cum
            să definiți egalitatea valorii pentru un tip". Înregistrările sunt tipuri de referință care utilizează
            semantica valorii pentru egalitate.
        </li>
        <li>Pentru a determina dacă valorile câmpurilor din două instanțe de clasă sunt egale, este posibil să puteți
            utiliza metoda Equals sau operatorul ==. Cu toate acestea, utilizați-le doar dacă clasa a suprascris sau
            supraincarcat aceste metode pentru a furniza o definiție personalizată a ceea ce înseamnă "egalitatea"
            pentru obiecte de acest tip. Clasa ar putea, de asemenea, să implementeze interfața IEquatable< T> sau
                IEqualityComparer< T>. Ambele interfețe furnizează metode care pot fi utilizate pentru a testa
                    egalitatea valorilor. Atunci când proiectați propriile clase care suprascriu Equals, asigurați-vă că
                    urmați ghidurile stabilite în "Cum să definiți egalitatea valorii pentru un tip" și
                    "Object.Equals(Object)".</li>
    </ul>
    <h2>4.2.4 Secțiunile relevante</h2>
    <p>Pentru mai multe informații:</p>
    <ul>
        <li>Clase</li>
        <li>Constructori</li>
        <li>Finalizatori</li>
        <li>Evenimente</li>
        <li>Obiect</li>
        <li>Moștenirea</li>
        <li>Clasă</li>
        <li>Tipuri de structuri</li>
        <li>Operatorul "new"</li>
        <li>Common Type System</li>
    </ul>


    <h1>4.3 Moștenirea</h1>
    <h2>4.3.1 Moștenirea - derivarea de tipuri pentru a crea comportamente mai specializate</h2>
    <p>Moștenirea, împreună cu încapsularea și polimorfismul, este una dintre cele trei caracteristici primare ale
        programării orientate pe obiect. Moștenirea vă permite să creați clase noi care reutilizează, extind și modifică
        comportamentul definit în alte clase. Clasa al cărei membrii sunt moșteniți se numește clasă de bază, iar clasa
        care moștenește acei membri se numește clasă derivată. O clasă derivată poate avea doar o clasă de bază directă.
        Cu toate acestea, moștenirea este tranzitivă. Dacă Clasa C este derivată din Clasa B, iar Clasa B este derivată
        din Clasa A, Clasa C moștenește membrii declarați în Clasa B și Clasa A.</p>
    <h3>Notă:
        <strong>Structurile nu suportă moștenirea, dar pot implementa interfețe.</strong>
    </h3>
    <p>Conceptual, o clasă derivată reprezintă o specializare a clasei de bază. De exemplu, dacă aveți o clasă de bază
        Animal, puteți avea o clasă derivată numită Mamifer și o altă clasă derivată numită Reptilă. Un Mamifer este un
        Animal, iar o Reptilă este un Animal, dar fiecare clasă derivată reprezintă specializări diferite ale clasei de
        bază.</p>
    <p>Declarațiile de interfață pot defini o implementare implicită pentru membrii lor. Aceste implementări sunt
        moștenite de către interfețele derivate și de către clasele care implementează acele interfețe. Pentru mai multe
        informații despre metodele implicite ale interfețelor, consultați articolul despre "Interfețe."</p>
    <p>Atunci când definiți o clasă derivată dintr-o altă clasă, clasa derivată primește implicit toți membrii clasei de
        bază, cu excepția constructorilor și a finalizatorilor săi. Clasa derivată reutilizează codul din clasa de bază
        fără a-l reimplementa. Puteți adăuga mai mulți membri în clasa derivată. Clasa derivată extinde funcționalitatea
        clasei de bază.</p>
    <p>Ilustrația următoare arată o clasă WorkItem care reprezintă un element de lucru într-un proces de afaceri. La fel
        ca toate clasele, aceasta derivă din System.Object și moștenește toate metodele sale. Clasa WorkItem adaugă șase
        membri proprii, inclusiv un constructor, deoarece constructorii nu sunt moșteniți. Clasa ChangeRequest
        moștenește de la clasa WorkItem și reprezintă un tip particular de element de lucru. Clasa ChangeRequest adaugă
        încă doi membri la cei moșteniți de la clasa WorkItem și de la Object. Trebuie să adauge propriul constructor și
        de asemenea adaugă originalItemID. Proprietatea originalItemID permite instanței ChangeRequest să fie asociată
        cu WorkItem-ul original la care se aplică cererea de modificare.</p>
    <p>Următorul exemplu arată cum relațiile între clasele prezentate în ilustrația anterioară sunt exprimate în C#.
        Exemplul arată și cum clasa WorkItem suprascrie metoda virtuală Object.ToString și cum clasa ChangeRequest
        moștenește implementarea metodei din clasa WorkItem. Primul bloc definește clasele:</p>
    <pre>
    <code>
        // WorkItem implicitly inherits from the Object class.
public class WorkItem
{
    // Static field currentID stores the job ID of the last WorkItem that
    // has been created.
    private static int currentID;

    //Properties.
    protected int ID { get; set; }
    protected string Title { get; set; }
    protected string Description { get; set; }
    protected TimeSpan jobLength { get; set; }

    // Default constructor. If a derived class does not invoke a base-
    // class constructor explicitly, the default constructor is called
    // implicitly.
    public WorkItem()
    {
        ID = 0;
        Title = "Default title";
        Description = "Default description.";
        jobLength = new TimeSpan();
    }

    // Instance constructor that has three parameters.
    public WorkItem(string title, string desc, TimeSpan joblen)
    {
        this.ID = GetNextID();
        this.Title = title;
        this.Description = desc;
        this.jobLength = joblen;
    }

    // Static constructor to initialize the static member, currentID. This
    // constructor is called one time, automatically, before any instance
    // of WorkItem or ChangeRequest is created, or currentID is referenced.
    static WorkItem() => currentID = 0;

    // currentID is a static field. It is incremented each time a new
    // instance of WorkItem is created.
    protected int GetNextID() => ++currentID;

    // Method Update enables you to update the title and job length of an
    // existing WorkItem object.
    public void Update(string title, TimeSpan joblen)
    {
        this.Title = title;
        this.jobLength = joblen;
    }

    // Virtual method override of the ToString method that is inherited
    // from System.Object.
    public override string ToString() =>
        $"{this.ID} - {this.Title}";
}

// ChangeRequest derives from WorkItem and adds a property (originalItemID)
// and two constructors.
public class ChangeRequest : WorkItem
{
    protected int originalItemID { get; set; }

    // Constructors. Because neither constructor calls a base-class
    // constructor explicitly, the default constructor in the base class
    // is called implicitly. The base class must contain a default
    // constructor.

    // Default constructor for the derived class.
    public ChangeRequest() { }

    // Instance constructor that has four parameters.
    public ChangeRequest(string title, string desc, TimeSpan jobLen,
                         int originalID)
    {
        // The following properties and the GetNexID method are inherited
        // from WorkItem.
        this.ID = GetNextID();
        this.Title = title;
        this.Description = desc;
        this.jobLength = jobLen;

        // Property originalItemID is a member of ChangeRequest, but not
        // of WorkItem.
        this.originalItemID = originalID;
    }
}
    </code>
</pre>
    <p>Acest bloc următor arată cum să utilizați clasele de bază și derivate:</p>
    <pre>
    <code>
        // Create an instance of WorkItem by using the constructor in the
// base class that takes three arguments.
WorkItem item = new WorkItem("Fix Bugs",
                            "Fix all bugs in my code branch",
                            new TimeSpan(3, 4, 0, 0));

// Create an instance of ChangeRequest by using the constructor in
// the derived class that takes four arguments.
ChangeRequest change = new ChangeRequest("Change Base Class Design",
                                        "Add members to the class",
                                        new TimeSpan(4, 0, 0),
                                        1);

// Use the ToString method defined in WorkItem.
Console.WriteLine(item.ToString());

// Use the inherited Update method to change the title of the
// ChangeRequest object.
change.Update("Change the Design of the Base Class",
    new TimeSpan(4, 0, 0));

// ChangeRequest inherits WorkItem's override of ToString.
Console.WriteLine(change.ToString());
/* Output:
    1 - Fix Bugs
    2 - Change the Design of the Base Class
*/
    </code>
</pre>


    <h2>4.3.2 Metode abstracte și virtuale</h2>
    <p>Atunci când o clasă de bază declară o metodă ca fiind virtuală, o clasă derivată poate să o suprascrie cu propria
        implementare. Dacă o clasă de bază declară un membru ca fiind abstract, acea metodă trebuie să fie suprascrisă
        în oricare clasă ne-abstractă care moștenește direct clasa respectivă. Dacă o clasă derivată este ea însăși
        abstractă, moștenește membrii abstracți fără a-i implementa. Membrii abstracți și virtuali sunt baza pentru
        polimorfism, care este a doua caracteristică primară a programării orientate pe obiect. Pentru mai multe
        informații, consultați "Polimorfismul."</p>


    <h2>4.3.3 Clase de bază abstracte</h2>
    <p>Puteți declara o clasă ca fiind abstractă dacă doriți să preveniți instanțierea directă folosind operatorul new.
        O clasă abstractă poate fi utilizată doar dacă o clasă nouă este derivată din ea. O clasă abstractă poate
        conține una sau mai multe semnături de metode care sunt ele însele declarate ca fiind abstracte. Aceste
        semnături specifică parametrii și valoarea de returnare, dar nu au implementare (corpul metodei). O clasă
        abstractă nu trebuie să conțină membri abstracți; totuși, dacă o clasă conține un membru abstract, clasa însăși
        trebuie să fie declarată ca fiind abstractă. Clasele derivate care nu sunt ele însele abstracte trebuie să ofere
        implementarea pentru orice metode abstracte dintr-o clasă de bază abstractă.</p>


    <h2>4.3.4 Interfețe</h2>
    <p>Interfața este un tip de referință care definește un set de membri. Toate clasele și structurile care
        implementează acea interfață trebuie să implementeze acel set de membri. O interfață poate defini o implementare
        implicită pentru oricare sau pentru toți acești membri. O clasă poate implementa mai multe interfețe, chiar dacă
        poate deriva doar dintr-o singură clasă de bază directă.</p>
    <p>Interfețele sunt utilizate pentru a defini capacități specifice pentru clase care nu au neapărat o relație de
        "este un" (is a). De exemplu, interfața System.IEquatable< T> poate fi implementată de orice clasă sau structură
            pentru a determina dacă două obiecte de acel tip sunt echivalente (în funcție de cum este definită
            echivalența pentru acel tip). IEquatable< T> nu implică același tip de relație "este un" (is a) ca între o
                clasă de bază și o clasă derivată (de exemplu, un Mamifer este un Animal). Pentru mai multe informații,
                consultați "Interfețele."</p>


    <h2>4.3.5 Prevenirea derivării ulterioare</h2>
    <p>O clasă poate preveni alte clase să moștenească de la ea, sau de la oricare dintre membrii săi, prin declararea
        sa sau a membrului ca fiind sigilat (sealed).</p>


    <h2>4.3.6 Ascunderea membrilor clasei de bază în clasele derivate</h2>
    <p>O clasă derivată poate ascunde membrii clasei de bază declarând membri cu același nume și semnătură.
        Modificatorul new poate fi utilizat pentru a indica în mod explicit că membrul nu este intenționat să fie o
        suprascriere a membrului de bază. Utilizarea cuvântului cheie new nu este obligatorie, dar va genera un
        avertisment de compilare dacă new nu este folosit. Pentru mai multe informații, consultați "Versioning with the
        Override and New Keywords" și "Knowing When to Use Override and New Keywords".</p>


    <h1>4.4 Polimorfismul</h1>
    <p>Polimorfismul este adesea numit al treia "pilon" al programării orientate pe obiect, după încapsulare și
        moștenire. Polimorfismul este un cuvânt de origine greacă care înseamnă "multe forme" și are două aspecte
        distincte:</p>
    <ul>
        <li>La momentul execuției, obiectele unei clase derivate pot fi tratate ca obiecte ale unei clase de bază în
            locuri precum parametri de metode, colecții sau array-uri. Când acest polimorfism are loc, tipul declarat al
            obiectului nu mai este identic cu tipul său real la momentul execuției. </li>
        <li>Clasele de bază pot defini și implementa metode virtuale, iar clasele derivate pot să le suprascrie, adică
            să ofere propria lor definiție și implementare. La momentul execuției, când codul client apelează metoda,
            motorul de execuție al CLR (Common Language Runtime) caută tipul real al obiectului și apelează
            suprascrierea acelei metode virtuale. În codul sursă, puteți apela o metodă pe o clasă de bază și să cauzați
            executarea versiunii respective a metodei dintr-o clasă derivată.</li>
    </ul>
    <p>Metodele virtuale vă permit să lucrați cu grupuri de obiecte într-un mod uniform. Să luăm exemplul unei aplicații
        de desenat care permite utilizatorului să creeze diferite tipuri de forme pe o suprafață de desen. La momentul
        compilării nu se știe exact ce tipuri de forme va crea utilizatorul. Cu toate acestea, aplicația trebuie să țină
        evidența tuturor tipurilor de forme create și să le actualizeze în funcție de acțiunile utilizatorului cu
        mouse-ul. Puteți utiliza polimorfismul pentru a rezolva această problemă în două pași de bază:</p>
    <ol>
        <li>Creați o ierarhie de clase în care fiecare clasă specifică de forme derivă dintr-o clasă de bază comună.
        </li>
        <li>Utilizați o metodă virtuală pentru a invoca metoda corespunzătoare pe oricare dintre clasele derivate
            printr-un singur apel la metoda clasei de bază.</li>
    </ol>
    <p>În primul rând, creați o clasă de bază numită Shape, și clase derivate precum Rectangle, Circle și Triangle. Dați
        clasei Shape o metodă virtuală numită Draw, și suprascrieți-o în fiecare clasă derivată pentru a desena forma
        specifică pe care clasa o reprezintă. Creați un obiect List< Shape> și adăugați un cerc (Circle), un triunghi
            (Triangle) și un dreptunghi (Rectangle) în listă.</p>
    <pre>
    <code>
        public class Shape
{
    // A few example members
    public int X { get; private set; }
    public int Y { get; private set; }
    public int Height { get; set; }
    public int Width { get; set; }

    // Virtual method
    public virtual void Draw()
    {
        Console.WriteLine("Performing base class drawing tasks");
    }
}

public class Circle : Shape
{
    public override void Draw()
    {
        // Code to draw a circle...
        Console.WriteLine("Drawing a circle");
        base.Draw();
    }
}
public class Rectangle : Shape
{
    public override void Draw()
    {
        // Code to draw a rectangle...
        Console.WriteLine("Drawing a rectangle");
        base.Draw();
    }
}
public class Triangle : Shape
{
    public override void Draw()
    {
        // Code to draw a triangle...
        Console.WriteLine("Drawing a triangle");
        base.Draw();
    }
}
    </code>
</pre>
    <p>Pentru a actualiza suprafața de desen, utilizați o buclă foreach pentru a itera prin listă și a apela metoda Draw
        pe fiecare obiect Shape din listă. Chiar dacă fiecare obiect din listă are un tip declarat de Shape, va fi
        invocată versiunea suprascrisă a metodei din fiecare clasă derivată (tipul de runtime) în timpul apelului.</p>
    <pre>
    <code>
        // Polymorphism at work #1: a Rectangle, Triangle and Circle
// can all be used wherever a Shape is expected. No cast is
// required because an implicit conversion exists from a derived
// class to its base class.
var shapes = new List<Shape>
{
    new Rectangle(),
    new Triangle(),
    new Circle()
};

// Polymorphism at work #2: the virtual method Draw is
// invoked on each of the derived classes, not the base class.
foreach (var shape in shapes)
{
    shape.Draw();
}
/* Output:
    Drawing a rectangle
    Performing base class drawing tasks
    Drawing a triangle
    Performing base class drawing tasks
    Drawing a circle
    Performing base class drawing tasks
*/
    </code>
</pre>
    <p>În C#, fiecare tip este polimorfic deoarece toate tipurile, inclusiv tipurile definite de utilizator, moștenesc
        de la Object.</p>


    <h2>4.4.1 Prezentarea generală a polimorfismului</h2>
    <h3>Membrii virtuali</h3>
    <p>Atunci când o clasă derivată moștenește de la o clasă de bază, ea include toți membrii clasei de bază. Toată
        comportamentul declarat în clasa de bază face parte din clasa derivată. Aceasta permite obiectelor clasei
        derivate să fie tratate ca obiecte ale clasei de bază. Modificatorii de acces (public, protected, private etc.)
        determină dacă acei membri sunt accesibili din implementarea clasei derivate. Metodele virtuale oferă
        designerului diferite opțiuni pentru comportamentul clasei derivate:</p>
    <ul>
        <li>
            Clasa derivată poate suprascrie membrii virtuali din clasa de bază, definind un comportament nou.
        </li>
        <li>Clasa derivată poate moșteni metoda celei mai apropiate clase de bază fără a o suprascrie, păstrând
            comportamentul existent, dar permitând claselor derivate ulterioare să o suprascrie.</li>
        <li>Clasa derivată poate defini o nouă implementare non-virtuală a acelor membrii care ascund implementările
            clasei de bază.</li>
    </ul>
    <p>O clasă derivată poate suprascrie un membru al unei clase de bază doar dacă membrul clasei de bază este declarat
        ca fiind virtual sau abstract. Membrul derivat trebuie să folosească cuvântul cheie "override" pentru a indica
        explicit că metoda este destinată să participe la invocarea virtuală. Codul de mai jos furnizează un exemplu:
    </p>
    <pre>
    <code>
        public class BaseClass
{
    public virtual void DoWork() { }
    public virtual int WorkProperty
    {
        get { return 0; }
    }
}
public class DerivedClass : BaseClass
{
    public override void DoWork() { }
    public override int WorkProperty
    {
        get { return 0; }
    }
}
    </code>
</pre>
    <p>Câmpurile nu pot fi declarate ca fiind virtuale; doar metodele, proprietățile, evenimentele și indexatorii pot fi
        declarate ca fiind virtuale. Atunci când o clasă derivată suprascrie un membru virtual, acel membru este apelat
        chiar și atunci când o instanță a acelei clase este accesată ca o instanță a clasei de bază. Codul de mai jos
        furnizează un exemplu:</p>
    <pre>
    <code>
        DerivedClass B = new DerivedClass();
B.DoWork();  // Calls the new method.

BaseClass A = B;
A.DoWork();  // Also calls the new method.
    </code>
</pre>
    <p>Metodele și proprietățile virtuale permit claselor derivate să extindă o clasă de bază fără a fi nevoie să
        utilizeze implementarea clasei de bază a unei metode. Pentru mai multe informații, consultați "Versioning with
        the Override and New Keywords". O interfață oferă o altă modalitate de a defini o metodă sau un set de metode
        ale căror implementări sunt lăsate în seama claselor derivate.</p>


    <h2>4.4.2 Ascunderea membrilor clasei de bază cu membrii noi.</h2>
    <p>Dacă doriți ca clasa derivată să aibă un membru cu același nume ca un membru în clasa de bază, puteți utiliza
        cuvântul cheie "new" pentru a ascunde membrul clasei de bază. Cuvântul cheie "new" este plasat înaintea tipului
        de returnare al membrului clasei care este înlocuit. Codul de mai jos oferă un exemplu:</p>
    <pre>
    <code>
        public class BaseClass
{
    public void DoWork() { WorkField++; }
    public int WorkField;
    public int WorkProperty
    {
        get { return 0; }
    }
}

public class DerivedClass : BaseClass
{
    public new void DoWork() { WorkField++; }
    public new int WorkField;
    public new int WorkProperty
    {
        get { return 0; }
    }
}
    </code>
</pre>
    <p>Membrii ascunși ai clasei de bază pot fi accesați din codul clientului prin conversia instanței clasei derivate
        într-o instanță a clasei de bază. De exemplu:</p>
    <pre>
    <code>
        DerivedClass B = new DerivedClass();
B.DoWork();  // Calls the new method.

BaseClass A = (BaseClass)B;
A.DoWork();  // Calls the old method.
    </code>
</pre>


    <h2>4.4.3 Prevenirea claselor derivate să supraîncarce membrii virtuali</h2>
    <p>Membrii virtuali rămân virtuali, indiferent de câte clase au fost declarate între membrul virtual și clasa care
        l-a declarat inițial. Dacă clasa A declară un membru virtual, iar clasa B derivă din A, iar clasa C derivă din
        B, clasa C moștenește membrul virtual și poate să-l suprascrie, indiferent de faptul că clasa B a declarat o
        suprascriere pentru acel membru. Codul de mai jos oferă un exemplu:</p>
    <pre>
    <code>
        public class A
{
    public virtual void DoWork() { }
}
public class B : A
{
    public override void DoWork() { }
}
    </code>
</pre>
    <p>O clasă derivată poate opri moștenirea virtuală declarând o suprascriere ca "sealed". Pentru a opri moștenirea,
        este necesar să plasați cuvântul cheie "sealed" înaintea cuvântului cheie "override" în declarația membrului
        clasei. Codul de mai jos oferă un exemplu:</p>
    <pre>
    <code>
        public class C : B
{
    public sealed override void DoWork() { }
}
    </code>
</pre>
    <p>În exemplul anterior, metoda "DoWork" nu mai este virtuală pentru nicio clasă derivată de la C. Cu toate acestea,
        rămâne virtuală pentru instanțele de tip C, chiar dacă acestea sunt convertite la tipul B sau tipul A. Metodele
        sigilate pot fi înlocuite de către clasele derivate folosind cuvântul cheie "new", așa cum arată exemplul
        următor:</p>
    <pre>
    <code>
        public class D : C
{
    public new void DoWork() { }
}
    </code>
</pre>
    <p>În acest caz, dacă metoda "DoWork" este apelată pe obiectul de tip D utilizând o variabilă de tip D, se va apela
        implementarea "new" a metodei "DoWork" din clasa D. Dacă o variabilă de tip C, B sau A este folosită pentru a
        accesa o instanță de tip D, apelurile către metoda "DoWork" vor urma regulile de moștenire virtuală, rutând
        apelurile către implementarea metodei "DoWork" din clasa C.</p>


    <h2>4.4.4 Accesarea membrilor virtuali ai clasei de bază din clasele derivate</h2>
    <p>O clasă derivată care a înlocuit sau suprascris o metodă sau o proprietate poate totuși accesa metoda sau
        proprietatea din clasa de bază folosind cuvântul cheie "base". Codul de mai jos oferă un exemplu:</p>
    <pre>
    <code>
        public class Base
{
    public virtual void DoWork() {/*...*/ }
}
public class Derived : Base
{
    public override void DoWork()
    {
        //Perform Derived's work here
        //...
        // Call DoWork on base class
        base.DoWork();
    }
}
    </code>
</pre>
    <p>Pentru mai multe informații puteți consulta "base"</p>


    <h3>Notă:</h3>
    <strong>Se recomandă ca membrii virtuali să utilizeze cuvântul cheie "base" pentru a apela implementarea membrului
        din clasa de bază în propria implementare. Permiterea comportamentului clasei de bază să aibă loc permite clasei
        derivate să se concentreze pe implementarea comportamentului specific clasei derivate. Dacă implementarea clasei
        de bază nu este apelată, este responsabilitatea clasei derivate să facă ca comportamentul său să fie compatibil
        cu comportamentul clasei de bază.</strong>
</body>

</html>
