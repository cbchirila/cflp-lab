<h1>2. Sistemul de tipuri</h1>

<h2>2.5 Introducere Ã®n tipurile de Ã®nregistrÄƒri din C#</h2>

<p>
    O Ã®nregistrare Ã®n C# este o clasÄƒ sau o structurÄƒ care oferÄƒ o sintaxÄƒ È™i un comportament special pentru
    lucrul cu modelele de date.
</p>

<h3>CÃ¢nd se folosesc Ã®nregistrÄƒrile</h3>
<p>
    LuaÈ›i Ã®n considerare utilizarea unei Ã®nregistrÄƒri Ã®n locul unei clase sau structuri Ã®n urmÄƒtoarele scenarii:
</p>
<ul>
    <li>DoriÈ›i sÄƒ definiÈ›i un model de date care depinde de egalitatea valorilor.</li>
    <li>DoriÈ›i sÄƒ definiÈ›i un tip pentru care obiectele sunt imuabile.</li>
</ul>

<h4>Egalitatea valorilor</h4>
<p>
    Ãn cazul Ã®nregistrÄƒrilor, egalitatea valorilor Ã®nseamnÄƒ cÄƒ douÄƒ variabile de tipul Ã®nregistrare sunt egale dacÄƒ
    tipurile se potrivesc È™i dacÄƒ toate valorile proprietÄƒÈ›ilor È™i cÃ¢mpurilor se potrivesc. Pentru alte tipuri de
    referinÈ›Äƒ, cum ar fi clasele, egalitatea Ã®nseamnÄƒ egalitatea referinÈ›elor. Mai exact, douÄƒ variabile de tip
    clasÄƒ sunt egale dacÄƒ se referÄƒ la acelaÈ™i obiect. Metodele È™i operatorii care determinÄƒ egalitatea a douÄƒ
    instanÈ›e de Ã®nregistrare utilizeazÄƒ egalitatea valorilor.
</p>
<p>
    Nu toate modelele de date funcÈ›ioneazÄƒ bine cu egalitatea valorilor. De exemplu, Entity Framework Core depinde
    de egalitatea referinÈ›elor pentru a se asigura cÄƒ utilizeazÄƒ o singurÄƒ instanÈ›Äƒ a unui tip de entitate pentru
    ceea ce, din punct de vedere conceptual, este o singurÄƒ entitate. Din acest motiv, tipurile de Ã®nregistrÄƒri nu
    sunt adecvate pentru a fi utilizate ca tipuri de entitÄƒÈ›i Ã®n Entity Framework Core.
</p>

<h4>Imuabilitatea</h4>
<p>
    Un tip imuabil este un tip care vÄƒ Ã®mpiedicÄƒ sÄƒ modificaÈ›i valorile proprietÄƒÈ›ilor sau ale cÃ¢mpurilor unui obiect
    dupÄƒ ce acesta a fost instanÈ›iat. Imuabilitatea poate fi utilÄƒ atunci cÃ¢nd aveÈ›i nevoie ca un tip sÄƒ fie thread-safe
    sau cÃ¢nd vÄƒ bazaÈ›i pe faptul cÄƒ un cod hash rÄƒmÃ¢ne acelaÈ™i Ã®ntr-un tabel de dispersie. ÃnregistrÄƒrile oferÄƒ o
    sintaxÄƒ concisÄƒ pentru crearea È™i lucrul cu tipuri imuabile.
</p>
<p>
    Imutabilitatea nu este adecvatÄƒ pentru toate scenariile de date. Entity Framework Core, de exemplu, nu permite
    actualizarea cu tipuri de entitÄƒÈ›i imuabile.
</p>

<h3>Cum diferÄƒ Ã®nregistrÄƒrile de clase È™i structuri</h3>
<p>
    AceeaÈ™i sintaxÄƒ care declarÄƒ È™i instanÈ›iazÄƒ clasele sau structurile poate fi utilizatÄƒ pentru Ã®nregistrÄƒri. Trebuie
    doar sÄƒ Ã®nlocuiÈ›i cuvÃ¢ntul cheie <code>class</code> cu <code>record</code> sau sÄƒ utilizaÈ›i <code>record sturct</code>
    Ã®n loc de <code>struct</code>. De asemenea, aceeaÈ™i sintaxÄƒ pentru exprimarea relaÈ›iilor de moÈ™tenire este acceptatÄƒ
    de clasele record. ÃnregistrÄƒrile diferÄƒ de clase Ã®n urmÄƒtoarele moduri:
</p>
<ul>
    <li>PuteÈ›i utiliza parametri poziÈ›ionali pentru a crea È™i a instanÈ›ia un tip cu proprietÄƒÈ›i imuabile.</li>
    <li>
        AceleaÈ™i metode È™i operatori care indicÄƒ egalitatea sau inegalitatea referinÈ›elor Ã®n clase (cum ar fi
        <code>Object.Equals(Object)</code> È™i <code>==</code>) indicÄƒ egalitatea sau inegalitatea valorilor Ã®n
        Ã®nregistrÄƒri.
    </li>
    <li>PuteÈ›i utiliza o expresie with pentru a crea o copie a unui obiect imuabil cu valori noi Ã®n proprietÄƒÈ›ile selectate.</li>
    <li>
        Metoda <code>ToString</code> a unei Ã®nregistrÄƒri creeazÄƒ un È™ir de caractere formatat care afiÈ™eazÄƒ numele
        tipuluiunui obiect, precum È™i numele È™i valorile tuturor proprietÄƒÈ›ilor sale publice.
    </li>
    <li>
        O Ã®nregistrare poate moÈ™teni o altÄƒ Ã®nregistrare. O Ã®nregistrare nu poate moÈ™teni o clasÄƒ, iar o clasÄƒ nu poate
        moÈ™teni o Ã®nregistrare.
    </li>
</ul>
<p>
    Structurile de Ã®nregistrare diferÄƒ de structuri deoarece compilatorul sintetizeazÄƒ metodele pentru egalitate È™i <code>ToString</code>.
    Compilatorul sintetizeazÄƒ o metodÄƒ <code>Deconstruct</code> pentru structurile de Ã®nregistrÄƒri poziÈ›ionale.
</p>

<h3>Exemple</h3>
<p>
    UrmÄƒtorul exemplu defineÈ™te o Ã®nregistrare publicÄƒ care utilizeazÄƒ parametri poziÈ›ionali pentru a declara È™i a
    instanÈ›ia o Ã®nregistrare. Apoi, imprimÄƒ numele tipului È™i valorile proprietÄƒÈ›ilor:
</p>
<pre>
    <code>
        public record Person(string FirstName, string LastName);

        public static void Main()
        {
            Person person = new("Nancy", "Davolio");
            Console.WriteLine(person);
            // AfiÈ™eazÄƒ: Person { FirstName = Nancy, LastName = Davolio }
        }
    </code>
</pre>
<p>UrmÄƒtorul exemplu demonstreazÄƒ egalitatea valorilor Ã®n Ã®nregistrÄƒri:</p>
<pre>
    <code>
        public record Person(string FirstName, string LastName, string[] PhoneNumbers);

        public static void Main()
        {
            var phoneNumbers = new string[2];
            Person person1 = new("Nancy", "Davolio", phoneNumbers);
            Person person2 = new("Nancy", "Davolio", phoneNumbers);
            Console.WriteLine(person1 == person2); // afiÈ™eazÄƒ: True

            person1.PhoneNumbers[0] = "555-1234";
            Console.WriteLine(person1 == person2); // afiÈ™eazÄƒ: True

            Console.WriteLine(ReferenceEquals(person1, person2)); // afiÈ™eazÄƒ: False
        }
    </code>
</pre>
<p>
    UrmÄƒtorul exemplu demonstreazÄƒ utilizarea unei expresii with pentru a copia un obiect imuabil È™i a-i modifica
    una dintre proprietÄƒÈ›i:
</p>
<pre>
    <code>
        public record Person(string FirstName, string LastName)
        {
            public string[] PhoneNumbers { get; init; }
        }

        public static void Main()
        {
            Person person1 = new("Nancy", "Davolio") { PhoneNumbers = new string[1] };
            Console.WriteLine(person1);
            // afiÈ™eazÄƒ Person { FirstName = Nancy, LastName = Davolio, PhoneNumbers = System.String[] }

            Person person2 = person1 with { FirstName = "John" };
            Console.WriteLine(person2);
            // afiÈ™eazÄƒ Person { FirstName = John, LastName = Davolio, PhoneNumbers = System.String[] }
            Console.WriteLine(person1 == person2); // afiÈ™eazÄƒ: False

            person2 = person1 with { PhoneNumbers = new string[1] };
            Console.WriteLine(person2);
            // afiÈ™eazÄƒ Person { FirstName = Nancy, LastName = Davolio, PhoneNumbers = System.String[] }
            Console.WriteLine(person1 == person2); // afiÈ™eazÄƒ: False

            person2 = person1 with { };
            Console.WriteLine(person1 == person2); // afiÈ™eazÄƒ: True
        }
    </code>
</pre>


<h2>2.6 InterfeÈ›e - definirea comportamentului pentru mai multe tipuri</h2>

<p>
    O interfaÈ›Äƒ conÈ›ine definiÈ›ii pentru un grup de funcÈ›ionalitÄƒÈ›i conexe pe care o clasÄƒ neabstractÄƒ sau o structurÄƒ trebuie sÄƒ le implementeze.
    O interfaÈ›Äƒ poate defini metode statice, care trebuie sÄƒ aibÄƒ o implementare. De asemenea, o interfaÈ›Äƒ poate defini o implementare implicitÄƒ
    pentru membri.
    O interfaÈ›Äƒ nu poate declara date instanÈ›Äƒ, cum ar fi cÃ¢mpuri, proprietÄƒÈ›i autoimplementate sau evenimente de tip proprietate.
</p>

<p>
    Prin utilizarea interfeÈ›elor, puteÈ›i, de exemplu, sÄƒ includeÈ›i Ã®ntr-o clasÄƒ comportamente din mai multe surse. AceastÄƒ capacitate este
    importantÄƒ Ã®n C# deoarece limbajul nu acceptÄƒ moÈ™tenirea multiplÄƒ a claselor. Ãn plus, trebuie sÄƒ folosiÈ›i o interfaÈ›Äƒ dacÄƒ doriÈ›i
    sÄƒ simulaÈ›i moÈ™tenirea structurilor, deoarece acestea nu pot moÈ™teni efectiv de la o altÄƒ structurÄƒ sau clasÄƒ.
</p>
<p>
    O interfaÈ›Äƒ se defineÈ›e folosind cuvÃ¢ntul cheie <code>interface</code>, dupÄƒ cum aratÄƒ exemplul urmÄƒtor.
</p>

<pre>
    <code>
        interface IEquatable&ltT&gt
            {
                bool Equals(T obj);
            }
    </code>
</pre>
<p>
    Numele unei interfeÈ›e trebuie sÄƒ fie un nume valid de identificator C#. Prin convenÈ›ie, numele interfeÈ›elor Ã®ncep cu un <code>I</code> mare.
</p>
<p>
    Orice clasÄƒ sau structurÄƒ care implementeazÄƒ interfaÈ›a <code>IEquatable&ltT&gt</code> trebuie sÄƒ conÈ›inÄƒ o definiÈ›ie pentru o metodÄƒ 
    <code>Equals</code> care sÄƒ corespundÄƒ semnÄƒturii specificate de interfaÈ›Äƒ. Prin urmare, puteÈ›i presupune cÄƒ o clasÄƒ care implementeazÄƒ
    <code>IEquatable&ltT&gt</code> va conÈ›ine o metodÄƒ <code>Equals</code> cu ajutorul cÄƒreia o instanÈ›Äƒ a clasei poate determina dacÄƒ este egalÄƒ
    cu o altÄƒ instanÈ›Äƒ a aceleiaÈ™i clase.
</p>
<p>
    DefiniÈ›ia <code>IEquatable&ltT&gt</code> nu prevede o implementare pentru <code>Equals</code>. O clasÄƒ sau o structurÄƒ poate implementa mai
    multe interfeÈ›e, dar o clasÄƒ poate moÈ™teni doar dintr-o singurÄƒ clasÄƒ.
</p>
<p>
    InterfeÈ›ele pot conÈ›ine metode de instanÈ›Äƒ, proprietÄƒÈ›i, evenimente, indexatori sau orice combinaÈ›ie a acestor patru tipuri de membri.
    InterfeÈ›ele pot conÈ›ine constructori statici, cÃ¢mpuri, constante sau operatori. ÃncepÃ¢nd cu C# 11, membrii interfeÈ›ei care nu sunt
    cÃ¢mpuri pot fi declaraÈ›i de tipul <code>static abstract</code>. O interfaÈ›Äƒ nu poate conÈ›ine cÃ¢mpuri de instanÈ›Äƒ, contructori instanÈ›Äƒ sau =
    finalizatori. Membrii interfeÈ›ei sunt publici Ã®n mod implicit È™i puteÈ›i specifica Ã®n mod explicit modificatorii de acces,
    cum ar fi <code>public</code>, <code>internal</code>, <code>private</code>, <code>protected internal</code> sau <code>private protected</code>.
    Un membru privat trebuie sÄƒ aibÄƒ o implementare implicitÄƒ.
</p>
<p>
    Pentru a implementa un membru al unei interfeÈ›e, membrul corespunzÄƒtor al clasei care implementeazÄƒ trebuie
    sÄƒ fie public, sÄƒ nu fie static È™i sÄƒ aibÄƒ acelaÈ™i nume È™i semnÄƒturÄƒ ca È™i membrul interfeÈ›ei.
</p>
<h6>NotÄƒ</h6>
<p>
    Atunci cÃ¢nd o interfaÈ›Äƒ declarÄƒ membri statici, un tip care implementeazÄƒ interfaÈ›a respectivÄƒ poate declara,
    de asemenea, membri statici cu aceeaÈ™i semnÄƒturÄƒ. AceÈ™tia sunt distincÈ›i È™i identificaÈ›i Ã®n mod unic de membrul
    care declarÄƒ tipul. Membrul static declarat Ã®ntr-un tip nu suprascrie membrul static declarat Ã®n interfaÈ›Äƒ.
</p>
<p>
    O clasÄƒ sau o structurÄƒ care implementeazÄƒ o interfaÈ›Äƒ trebuie sÄƒ furnizeze o implementare pentru toÈ›i membrii
    declaraÈ›i care nu au o implementare implicitÄƒ furnizatÄƒ de interfaÈ›Äƒ. Cu toate acestea, Ã®n cazul Ã®n care o
    clasÄƒ de bazÄƒ implementeazÄƒ o interfaÈ›Äƒ, orice clasÄƒ derivatÄƒ din clasa de bazÄƒ moÈ™teneÈ™te acea implementare.
</p>
<p>
    UrmÄƒtorul exemplu prezintÄƒ o implementare a interfeÈ›ei <code>IEquatable&ltT&gt</code>. Clasa care o implementeazÄƒ,
    <code>Car</code>, trebuie sÄƒ furnizeze o implementare a metodei <code>Equals</code>.
</p>
<pre>
    <code>
        public class Car : IEquatable&ltCar&gt
            {
                public string? Make { get; set; }
                public string? Model { get; set; }
                public string? Year { get; set; }
            
                // Implementarea interfeÈ›ei IEquatable&ltT&gt
                public bool Equals(Car? car)
                {
                    return (this.Make, this.Model, this.Year) ==
                        (car?.Make, car?.Model, car?.Year);
                }
            }
    </code>
</pre>
<p>
    ProprietÄƒÈ›ile È™i indexorii unei clase pot defini accesori suplimentari pentru o proprietate sau un indexor
    definit Ã®ntr-o interfaÈ›Äƒ. De exemplu, o interfaÈ›Äƒ poate declara o proprietate care are un accesor <code>get</code>.
    Clasa care implementeazÄƒ interfaÈ›a poate declara aceeaÈ™i proprietate, avÃ¢nd atÃ¢t un accesor <code>get</code>, cÃ¢t È™i
    unul <code>set</code>. Cu toate acestea, Ã®n cazul Ã®n care proprietatea sau indexatorul utilizeazÄƒ o implementare
    explicitÄƒ, accesorii trebuie sÄƒ se potriveascÄƒ.
</p>
<p>
    InterfeÈ›ele pot moÈ™teni o interfaÈ›a sau mai multe interfeÈ›e. InterfaÈ›a derivatÄƒ moÈ™teneÈ™te membrii din
    interfeÈ›ele de bazÄƒ. O clasÄƒ care implementeazÄƒ o interfaÈ›Äƒ derivatÄƒ trebuie sÄƒ implementeze toÈ›i membrii din
    interfaÈ›a derivatÄƒ, inclusiv toÈ›i membrii interfeÈ›elor de bazÄƒ ale interfeÈ›ei derivate. Clasa respectivÄƒ poate
    fi convertitÄƒ implicit la interfaÈ›a derivatÄƒ sau la oricare dintre interfeÈ›ele de bazÄƒ ale acesteia. O clasÄƒ
    poate include o interfaÈ›Äƒ de mai multe ori prin clasele de bazÄƒ pe care le moÈ™teneÈ™te sau prin interfeÈ›e
    moÈ™tenite de alte interfeÈ›e. Cu toate acestea, clasa poate furniza o implementare a unei interfeÈ›e doar o
    singurÄƒ datÄƒ È™i doar dacÄƒ clasa declarÄƒ interfaÈ›a ca parte a definiÈ›iei clasei <code>(class ClassName : InterfaceName)</code>.
    Ãn cazul Ã®n care interfaÈ›a este moÈ™tenitÄƒ deoarece aÈ›i moÈ™tenit o clasÄƒ de bazÄƒ care implementeazÄƒ interfaÈ›a,
    clasa de bazÄƒ va asigura implementarea membrilor interfeÈ›ei. Cu toate acestea, clasa derivatÄƒ poate
    reimplementa orice membri virtuali ai interfeÈ›ei Ã®n loc sÄƒ utilizeze implementarea moÈ™tenitÄƒ. Atunci cÃ¢nd
    interfeÈ›ele declarÄƒ o implementare implicitÄƒ a unei metode, orice clasÄƒ care implementeazÄƒ acea interfaÈ›Äƒ
    moÈ™teneÈ™te acea implementare (Este necesar un cast al instanÈ›ei clasei la tipul interfeÈ›ei pentru a accesa
    implementarea implicitÄƒ definitÄƒ la nivelul membrului interfeÈ›ei).
</p>
<p>
    O clasÄƒ de bazÄƒ poate, de asemenea, sÄƒ implementeze membrii interfeÈ›ei prin utilizarea membrilor virtuali.
    Ãn acest caz, o clasÄƒ derivatÄƒ poate modifica comportamentul interfeÈ›ei prin suprascrierea membrilor virtuali. 
</p>
<h3>Rezumat interfeÈ›e</h3>
<p>
    O interfaÈ›Äƒ are urmÄƒtoarele proprietÄƒÈ›i:
    <ul>
        <li>
            Ãn versiunile C# anterioare versiunii 8.0, o interfaÈ›Äƒ este ca o clasÄƒ de bazÄƒ abstractÄƒ care are numai membri
            abstracÈ›i. O clasÄƒ sau o structurÄƒ care implementeazÄƒ interfaÈ›a trebuie sÄƒ implementeze toÈ›i membrii acesteia.
        </li>
        <li>
            ÃncepÃ¢nd cu versiunea C# 8.0, o interfaÈ›Äƒ poate defini implementÄƒri implicite pentru unii sau toÈ›i membrii sÄƒi.
            O clasÄƒ sau o structurÄƒ care implementeazÄƒ interfaÈ›a nu trebuie sÄƒ implementeze membrii care au implementÄƒri
            implicite.
        </li>
        <li>
            O interfaÈ›Äƒ nu poate fi instanÈ›iatÄƒ direct. Membrii sÄƒi sunt implementaÈ›i de orice clasÄƒ sau structurÄƒ care
            implementeazÄƒ interfaÈ›a.
        </li>
        <li>
            O clasÄƒ sau o structurÄƒ poate implementa mai multe interfeÈ›e. O clasÄƒ poate moÈ™teni o clasÄƒ de bazÄƒ È™i,
            totodatÄƒ, poate implementa una sau mai multe interfeÈ›e.
        </li>
    </ul>
</p>

<h2>2.7 Clase È™i metode generice</h2>

<p>
    Genericitatea introduce Ã®n .NET conceptul de parametri de tip, care fac posibilÄƒ proiectarea de clase È™i metode care Ã®ntÃ¢rzie specificarea unuia
    sau mai multor tipuri pÃ¢nÄƒ cÃ¢nd clasa sau metoda este declaratÄƒ È™i instanÈ›iatÄƒ de codul client. De exemplu, prin utilizarea unui parametru de
    tip generic <code>T</code>, puteÈ›i scrie o singurÄƒ clasÄƒ pe care alte coduri client o pot utiliza fÄƒrÄƒ a suporta costul sau riscul unor operaÈ›ii
    de cast sau boxing Ã®n timpul execuÈ›iei, aÈ™a cum se aratÄƒ aici:
</p>
<pre>
    <code>
        // Declarare clasÄƒ genericÄƒ.
        public class GenericList&ltT&gt
        {
            public void Add(T input) { }
        }
        class TestGenericList
        {
            private class ExampleClass { }
            static void Main()
            {
                // Declarare listÄƒ de tipul int.
                GenericList&ltint&gt list1 = new GenericList&ltint&gt();
                list1.Add(1);

                // Declarare listÄƒ de tipul string.
                GenericList&ltstring&gt list2 = new GenericList&ltstring&gt();
                list2.Add("");

                // Declarare listÄƒ de tipul ExampleClass.
                GenericList&ltExampleClass&gt list3 = new GenericList&ltExampleClass&gt();
                list3.Add(new ExampleClass());
            }
        }
    </code>
</pre>
<p>
    Clasele È™i metodele generice combinÄƒ capacitatea de reutilizare, siguranÈ›a tipurilor È™i eficienÈ›a Ã®ntr-un mod Ã®n care nu o pot face omologii lor
    ne-generici. Genericitatea este cel mai frecvent utilizatÄƒ Ã®n cazul colecÈ›iilor È™i al metodelor care opereazÄƒ cu acestea. SpaÈ›iul de nume
    <code>System.Collections.Generic</code> conÈ›ine mai multe clase de colecÈ›ii bazate pe generice. ColecÈ›iile ne-generice, cum ar fi
    <code>ArrayList</code>, nu sunt recomandate È™i sunt menÈ›inute Ã®n scopuri de compatibilitate.
</p>
<p>
    De asemenea, puteÈ›i crea tipuri È™i metode generice personalizate pentru a vÄƒ asigura propriile soluÈ›ii generalizate È™i modele de proiectare
    care sunt sigure din punct de vedere al tipurilor È™i eficiente. UrmÄƒtorul exemplu de cod prezintÄƒ o clasÄƒ genericÄƒ simplÄƒ de liste legate Ã®n
    scop demonstrativ. (Ãn majoritatea cazurilor, ar trebui sÄƒ utilizaÈ›i clasa <code>List&ltT&gt</code> furnizatÄƒ de .NET Ã®n loc sÄƒ vÄƒ creaÈ›i propria clasÄƒ).
    Parametrul de tip <code>T</code> este utilizat Ã®n mai multe locuri Ã®n care, Ã®n mod normal, ar trebui sÄƒ se utilizeze un tip concret pentru a indica
    tipul elementului stocat Ã®n listÄƒ. Acesta este utilizat Ã®n urmÄƒtoarele moduri:
</p>
<ul>
    <li>Ca tip al unui parametru de metodÄƒ al metodei <code>AddHead</code>.</li>
    <li>Ca tipul returnat al proprietÄƒÈ›ii <code>Data</code> din clasa imbricatÄƒ <code>Node</code>.</li>
    <li>Ca tip al membrului privat <code>data</code> al clasei imbricate.</li>
</ul>
<p>
    <code>T</code> este disponibil pentru clasa imbricata <code>Node</code>. Atunci cÃ¢nd <code>GenericList&ltT&gt</code> este instanÈ›iatÄƒ cu un tip concret, de
    exemplu ca <code>GenericList&ltint&gt</code>, fiecare apariÈ›ie a lui <code>T</code> va fi Ã®nlocuitÄƒ cu <code>int</code>.
</p>
<pre>
    <code>
        // parametrul de tip Ã®ntre paranteze
        public class GenericList&ltT&gt
        {
            // Clasa imbricata este, de asemenea, genericÄƒ, avÃ¢nd tipul T.
            private class Node
            {
                // T folosit Ã®ntr-un constructor nongeneric.
                public Node(T t)
                {
                    next = null;
                    data = t;
                }

                private Node? next;
                public Node? Next
                {
                    get { return next; }
                    set { next = value; }
                }

                // T ca tip de date al unui membru privat.
                private T data;

                // T ca tip returnat al unei proprietÄƒÈ›i.
                public T Data
                {
                    get { return data; }
                    set { data = value; }
                }
            }

            private Node? head;

            // constructor
            public GenericList()
            {
                head = null;
            }

            // T ca parametru de tip al unei metode:
            public void AddHead(T t)
            {
                Node n = new Node(t);
                n.Next = head;
                head = n;
            }

            public IEnumerator&ltT&gt GetEnumerator()
            {
                Node? current = head;

                while (current != null)
                {
                    yield return current.Data;
                    current = current.Next;
                }
            }
        }
    </code>
</pre>
<p>
    UrmÄƒtorul exemplu de cod aratÄƒ modul Ã®n care codul client utilizeazÄƒ clasa genericÄƒ <code>GenericList&ltT&gt</code> pentru a crea o listÄƒ de
    numere Ã®ntregi. Prin simpla schimbare a argumentului de tip, codul de mai jos ar putea fi modificat cu uÈ™urinÈ›Äƒ pentru a crea liste de È™iruri
    de caractere sau orice alt tip personalizat:
</p>
<pre>
    <code>
        class TestGenericList
        {
            static void Main()
            {
                // int este argumentul de tip
                GenericList&ltint&gt list = new GenericList&ltint&gt();

                for (int x = 0; x &lt 10; x++)
                {
                    list.AddHead(x);
                }

                foreach (int i in list)
                {
                    System.Console.Write(i + " ");
                }
                System.Console.WriteLine("\nDone");
            }
        }
    </code>
</pre>

<h3>Rezumat genericitate</h3>
<ul>
    <li>UtilizaÈ›i tipuri generice pentru a maximiza reutilizarea codului, siguranÈ›a tipurilor È™i performanÈ›a.</li>
    <li>Tipurile generice sunt folosite cel mai frecvent la crearea claselor de colecÈ›ii.</li>
    <li>
        Biblioteca de clase .NET conÈ›ine mai multe clase de colecÈ›ii generice Ã®n spaÈ›iul de nume <code>System.Collections.Generic</code>.
        ColecÈ›iile generice ar trebui utilizate ori de cÃ¢te ori este posibil Ã®n locul claselor precum <code>ArrayList</code> din spaÈ›iul de nume
        <code>System.Collections</code>.
    </li>
    <li>PuteÈ›i sÄƒ vÄƒ creaÈ›i propriile interfeÈ›e generice, clase, metode, evenimente È™i delegaÈ›i.</li>
    <li>Clasele generice pot fi restricÈ›ionate pentru a permite accesul la metode pentru anumite tipuri de date.</li>
    <li>
        InformaÈ›iile privind tipurile care sunt utilizate Ã®ntr-un tip de date generic pot fi obÈ›inute Ã®n timpul execuÈ›iei
        prin utilizarea mecanismului de reflecÈ›ie.
    </li>
</ul>

<h2>2.8 Tipuri anonime</h2>

<p>
    Tipurile anonime oferÄƒ o modalitate convenabilÄƒ de a Ã®ncapsula un set de proprietÄƒÈ›i read-only Ã®ntr-un
    singur obiect fÄƒrÄƒ a fi nevoie sÄƒ se defineascÄƒ mai Ã®ntÃ¢i Ã®n mod explicit un tip. Numele tipului este
    generat de compilator È™i nu este disponibil la nivelul codului sursÄƒ. Tipul fiecÄƒrei proprietÄƒÈ›i este
    dedus de compilator.
</p>
<p>
    Se creeazÄƒ tipuri anonime prin utilizarea operatorului <code>new</code> Ã®mpreunÄƒ cu un iniÈ›ializator de obiect.
</p>
<p>
    UrmÄƒtorul exemplu prezintÄƒ un tip anonim care este iniÈ›ializat cu douÄƒ proprietÄƒÈ›i numite <code>Amount</code>
    È™i <code>Message</code>.
</p>
<pre>
    <code>
        var v = new { Amount = 108, Message = "Hello" };

        Console.WriteLine(v.Amount + v.Message);
    </code>
</pre>
<p>
    Tipurile anonime sunt utilizate de obicei Ã®n clauza de selecÈ›ie a unei expresii de interogare pentru a
    returna un subset de proprietÄƒÈ›i din fiecare obiect din secvenÈ›a sursÄƒ. 
</p>
<p>
    Tipurile anonime conÈ›in una sau mai multe proprietÄƒÈ›i publice read-only. Nu sunt valide alte tipuri de
    membri ai clasei, precum metodele sau evenimentele. Expresia utilizatÄƒ pentru a iniÈ›ializa o proprietate
    nu poate fi <code>null</code>, o funcÈ›ie anonimÄƒ sau un pointer.
</p>
<p>
    Scenariul cel mai frecvent este acela de a iniÈ›ializa un tip anonim cu proprietÄƒÈ›i dintr-un alt tip. Ãn
    exemplul urmÄƒtor, sÄƒ presupunem cÄƒ existÄƒ o clasÄƒ numitÄƒ <code>Product</code>. Clasa <code>Product</code>
    include proprietÄƒÈ›ile <code>Color</code> È™i <code>Price</code>, Ã®mpreunÄƒ cu alte proprietÄƒÈ›i. Variabila
    <code>products</code> este o colecÈ›ie de obiecte <code>Product</code>. DeclaraÈ›ia de tip anonim Ã®ncepe cu
    cuvÃ¢ntul cheie <code>new</code>. DeclaraÈ›ia iniÈ›ializeazÄƒ un nou tip care utilizeazÄƒ doar douÄƒ
    proprietÄƒÈ›i din <code>Product</code>. Utilizarea tipurilor anonime face ca o cantitate mai micÄƒ de date
    sÄƒ fie returnatÄƒ Ã®n interogare.
</p>
<p>
    DacÄƒ nu specificaÈ›i numele membrilor Ã®n tipul anonim, compilatorul atribuie membrilor tipului anonim
    acelaÈ™i nume ca È™i proprietÄƒÈ›ii utilizate pentru a le iniÈ›ializa. PuteÈ›i furniza un nume pentru o
    proprietate care este iniÈ›ializatÄƒ cu o expresie, aÈ™a cum se aratÄƒ Ã®n exemplul anterior. Ãn exemplul
    urmÄƒtor, numele proprietÄƒÈ›ilor tipului anonim sunt <code>Color</code> È™i <code>Price</code>.
</p>
<pre>
    <code>
        var productQuery =
            from prod in products
            select new { prod.Color, prod.Price };

        foreach (var v in productQuery)
        {
            Console.WriteLine("Color={0}, Price={1}", v.Color, v.Price);
        }
    </code>
</pre>
<h6>Sfat</h6>
<p>
    PuteÈ›i utiliza regula .NET IDE0037 pentru a impune dacÄƒ sunt preferate numele de membru deduse sau explicite.
</p>
<p>
    De asemenea, este posibil sÄƒ se defineascÄƒ un cÃ¢mp prin intermediul unui obiect de alt tip: clasÄƒ,
    structurÄƒ sau chiar un alt tip anonim. Acest lucru se face prin utilizarea variabilei care conÈ›ine acest
    obiect, la fel ca Ã®n exemplul urmÄƒtor, Ã®n care douÄƒ tipuri anonime sunt create folosind tipuri definite de
    utilizator deja instanÈ›iate. Ãn ambele cazuri, cÃ¢mpul <code>product</code> din tipurile anonime <code>shipment</code>
    È™i <code>shipmentWithBonus</code> va fi de tip <code>Product</code> È™i va conÈ›ine valorile implicite ale
    fiecÄƒrui cÃ¢mp. Iar cÃ¢mpul <code>bonus</code> va fi de tip anonim creat de compilator.
</p>
<pre>
    <code>
        var product = new Product();
        var bonus = new { note = "You won!" };
        var shipment = new { address = "Nowhere St.", product };
        var shipmentWithBonus = new { address = "Somewhere St.", product, bonus };
    </code>
</pre>
<p>
    De obicei, atunci cÃ¢nd utilizaÈ›i un tip anonim pentru a iniÈ›ializa o variabilÄƒ, declaraÈ›i variabila ca o
    variabilÄƒ localÄƒ implicit tipizatÄƒ, utilizÃ¢nd <code>var</code>. Numele tipului nu poate fi specificat Ã®n declaraÈ›ia
    variabilei, deoarece numai compilatorul are acces la numele de bazÄƒ al tipului anonim.
</p>
<p>
    PuteÈ›i crea un tablou de elemente tipizate anonim prin combinarea unei variabile locale implicit tipizate
    È™i a unui tablou implicit tipizat, dupÄƒ cum se aratÄƒ Ã®n exemplul urmÄƒtor.
</p>
<pre>
    <code>
        var anonArray = new[] { new { name = "apple", diam = 4 }, new { name = "grape", diam = 1 }};
    </code>
</pre>
<p>
    Tipurile anonime sunt tipuri de clasÄƒ care derivÄƒ direct din <code>object</code> È™i care nu pot fi transformate Ã®n
    niciun alt tip, cu excepÈ›ia lui <code>object</code>. Compilatorul furnizeazÄƒ un nume pentru fiecare tip anonim, deÈ™i
    aplicaÈ›ia dumneavoastrÄƒ nu Ã®l poate accesa. Din punctul de vedere al timpului de execuÈ›ie (Common Language
    Runtime), un tip anonim nu este diferit de orice alt tip de referinÈ›Äƒ.
</p>
<p>
    Ãn cazul Ã®n care doi sau mai mulÈ›i iniÈ›ializatori de obiecte anonime dintr-un ansamblu specificÄƒ o
    secvenÈ›Äƒ de proprietÄƒÈ›i care se aflÄƒ Ã®n aceeaÈ™i ordine È™i care au aceleaÈ™i nume È™i tipuri, compilatorul
    trateazÄƒ obiectele ca fiind instanÈ›e de acelaÈ™i tip. Ele au Ã®n comun aceleaÈ™i informaÈ›ii de tip generate
    de compilator.
</p>
<p>
    Tipurile anonime acceptÄƒ mutaÈ›ii nedistructive sub forma expresiilor <code>with</code>. Acest lucru vÄƒ
    permite sÄƒ creaÈ›i o nouÄƒ instanÈ›Äƒ a unui tip anonim Ã®n care una sau mai multe proprietÄƒÈ›i au valori noi:
</p>
<pre>
    <code>
        var apple = new { Item = "apples", Price = 1.35 };
        var onSale = apple with { Price = 0.79 };
        Console.WriteLine(apple);
        Console.WriteLine(onSale);
    </code>
</pre>
<p>
    Nu puteÈ›i declara un cÃ¢mp, o proprietate, un eveniment sau tipul de returnare al unei metode ca avÃ¢nd un
    tip anonim. Ãn mod similar, nu puteÈ›i declara un parametru formal al unei metode, al unei proprietÄƒÈ›i, al
    unui constructor sau al unui indexor ca avÃ¢nd un tip anonim. Pentru a transmite un tip anonim sau o
    colecÈ›ie care conÈ›ine tipuri anonime ca argument al unei metode, puteÈ›i declara parametrul ca fiind de tip <code>object</code>.
    Cu toate acestea, utilizarea <code>object</code> pentru tipurile anonime contravine scopului tipizÄƒrii puternice. DacÄƒ
    trebuie sÄƒ stocaÈ›i rezultatele interogÄƒrii sau sÄƒ le transmiteÈ›i Ã®n afara limitei metodei, luaÈ›i Ã®n
    considerare utilizarea unei structuri sau clase cu nume obiÈ™nuit Ã®n locul unui tip anonim.
</p>
<p>
    Deoarece metodele <code>Equals</code> È™i <code>GetHashCode</code> ale tipurilor anonime sunt definite Ã®n
    funcÈ›ie de metodele Equals È™i GetHashCode ale proprietÄƒÈ›ilor, douÄƒ instanÈ›e ale aceluiaÈ™i tip anonim sunt
    egale numai dacÄƒ toate proprietÄƒÈ›ile lor sunt egale.
</p>
<p>
    Tipurile anonime suprascriu metoda <code>ToString</code>, concatenÃ¢nd numele È™i rezultatul <code>ToString</code>
    al fiecÄƒrei proprietÄƒÈ›i Ã®nconjurate de acolade.
</p>
<pre>
    <code>
        var v = new { Title = "Hello", Age = 24 };

        Console.WriteLine(v.ToString()); // "{ Title = Hello, Age = 24 }"
    </code>
</pre>

<h2>2.9 È˜iruri de caractere È™i literali de È™iruri</h2>

<p>
    Un È™ir de caractere este un obiect de tip String a cÄƒrui valoare este text. Pe plan intern, textul este
    stocat ca o colecÈ›ie secvenÈ›ialÄƒ de obiecte <code>Char</code>, numai pentru citire. La sfÃ¢rÈ™itul unui È™ir de caractere
    C# nu existÄƒ un terminator de È™ir, prin urmare, un È™ir C# poate conÈ›ine orice numÄƒr de caractere zero
    Ã®ncorporate ("\0"). Proprietatea <code>Length</code> a unui È™ir reprezintÄƒ numÄƒrul de obiecte Char pe care le conÈ›ine,
    nu numÄƒrul de caractere Unicode. Pentru a accesa punctele de cod Unicode individuale dintr-un È™ir,
    utilizaÈ›i obiectul <code>StringInfo</code>.
</p>

<h3>string vs System.String</h3>
<p>
    Ãn C#, cuvÃ¢ntul cheie <code>string</code> este un alias pentru <code>String</code>. Prin urmare, <code>String</code>
    È™i <code>string</code> sunt echivalente. Se recomandÄƒ utilizarea aliasului furnizat <code>string</code>,
    deoarece acesta funcÈ›ioneazÄƒ chiar È™i fÄƒrÄƒ a utiliza <code>System</code>. Clasa <code>String</code> oferÄƒ
    multe metode pentru crearea, manipularea È™i compararea Ã®n siguranÈ›Äƒ a È™irurilor de caractere. Ãn plus,
    limbajul C# supraÃ®ncarcÄƒ unii operatori pentru a simplifica operaÈ›iile comune cu È™iruri de caractere.
</p>

<h3>Declararea È™i iniÈ›ializarea È™irurilor de caractere</h3>
<p>
    PuteÈ›i declara È™i iniÈ›ializa È™irurile de caractere Ã®n diferite feluri, precum se aratÄƒ Ã®n exemplul urmÄƒtor:
</p>
<pre>
    <code>
        // Declarare fÄƒrÄƒ iniÈ›ializare.
        string message1;

        // IniÈ›ializare cu null.
        string message2 = null;

        // IniÈ›ializare ca È™ir de caractere vid.
        // FolosiÈ›i constanta Empty Ã®n loc de "".
        string message3 = System.String.Empty;

        // InitiÈ›ializare cu un literal de string.
        string oldPath = "c:\\Program Files\\Microsoft Visual Studio 8.0";

        // IniÈ›ializare cu un literal de string verbatim.
        string newPath = @"c:\Program Files\Microsoft Visual Studio 9.0";

        // FolosiÈ›i System.String dacÄƒ preferaÈ›i.
        System.String greeting = "Hello World!";

        // Pentru variabilele locale (adicÄƒ Ã®n corpul unei metode) se poate utiliza tipizarea implicitÄƒ.
        var temp = "I'm still a strongly-typed System.String!";

        // FolosiÈ›i un È™ir const pentru a preveni ca 'message4'
        // sÄƒ fie folosit pentru a stoca o altÄƒ valoare de È™ir.
        const string message4 = "You can't get rid of me!";

        // FolosiÈ›i constructorul String numai atunci cÃ¢nd creaÈ›i
        // un È™ir de caractere dintr-un char*, char[] sau sbyte*.
        char[] letters = { 'A', 'B', 'C' };
        string alphabet = new string(letters);
    </code>
</pre>
<p>
    Operatorul <code>new</code> nu se utilizeazÄƒ pentru a crea un obiect È™ir de caractere, cu excepÈ›ia cazului
    Ã®n care se iniÈ›ializeazÄƒ È™irul de caractere cu un tablou de caractere.
</p>
<p>
    IniÈ›ializaÈ›i un È™ir de caractere cu valoarea constantÄƒ <code>Empty</code> pentru a crea un nou obiect
    <code>String</code> al cÄƒrui È™ir de caractere este de lungime zero. Reprezentarea literalÄƒ a unui È™ir de
    lungime zero este <code>""</code>. Prin iniÈ›ializarea È™irurilor de caractere cu valoarea <code>Empty</code>
    Ã®n loc de <code>null</code>, puteÈ›i reduce È™ansele de apariÈ›ie a unei excepÈ›ii <code>NullReferenceException</code>.
    UtilizaÈ›i metoda staticÄƒ <code>IsNullOrEmpty(String)</code> pentru a verifica valoarea unui È™ir de caractere
    Ã®nainte de a Ã®ncerca sÄƒ Ã®l accesaÈ›i.
</p>

<h3>Imuabilitatea È™irurilor de caractere</h3>
<p>
    Obiectele de tip string sunt <i>imuabile</i>: nu pot fi modificate dupÄƒ ce au fost create. Toate metodele
    <code>String</code> È™i toÈ›i operatorii C# care par sÄƒ modifice un È™ir de caractere returneazÄƒ de fapt
    rezultatele Ã®ntr-un nou obiect <code>String</code>. Ãn exemplul urmÄƒtor, atunci cÃ¢nd conÈ›inutul lui <code>s1</code>
    È™i <code>s2</code> este concatenat pentru a forma un singur È™ir, cele douÄƒ È™iruri originale nu sunt
    modificate. Operatorul <code>+=</code> creeazÄƒ un nou È™ir de caractere care conÈ›ine conÈ›inutul combinat.
    Acest nou obiect este atribuit variabilei <code>s1</code>, iar obiectul original care a fost atribuit lui
    <code>s1</code>, este eliberat Ã®n vederea colectÄƒrii gunoiului deoarece nicio altÄƒ variabilÄƒ nu mai conÈ›ine o referinÈ›Äƒ la acesta.
</p>
<pre>
    <code>
        string s1 = "A string is more ";
        string s2 = "than the sum of its chars.";

        // ConcateneazÄƒ s1 È™i s2. Acest lucru creeazÄƒ de fapt un nou
        // obiect È™ir de caractere È™i Ã®l stocheazÄƒ Ã®n s1, eliberÃ¢nd
        // referinÈ›a la obiectul original.
        s1 += s2;

        System.Console.WriteLine(s1);
        // AfiÈ™eazÄƒ: A string is more than the sum of its chars.
    </code>
</pre>
<p>
    Deoarece o "modificare" a unui È™ir de caractere este de fapt o nouÄƒ creare de È™iruri, trebuie sÄƒ fiÈ›i
    precauÈ›i atunci cÃ¢nd creaÈ›i referinÈ›e la È™iruri de caractere. DacÄƒ creaÈ›i o referinÈ›Äƒ la un È™ir de
    caractere, iar apoi "modificaÈ›i" È™irul original, referinÈ›a va continua sÄƒ indice obiectul original Ã®n loc
    de noul obiect care a fost creat atunci cÃ¢nd È™irul a fost modificat. Codul urmÄƒtor ilustreazÄƒ acest
    comportament:
</p>
<pre>
    <code>
        string str1 = "Hello ";
        string str2 = str1;
        str1 += "World";

        System.Console.WriteLine(str2);
        //AfiÈ™eazÄƒ: Hello
    </code>
</pre>

<h3>Literalii de È™iruri de caractere Ã®ntre ghilimele</h3>
<p>
    È˜irurile de caractere Ã®ntre ghilimele Ã®ncep È™i se terminÄƒ cu un singur caracter de ghilimele duble
    (<code>"</code>) pe aceeaÈ™i linie. È˜irurile de caractere Ã®ntre ghilimele sunt cele mai potrivite pentru
    È™irurile care Ã®ncap pe o singurÄƒ linie È™i nu includ secvenÈ›e de scÄƒpare. Un literal de È™ir Ã®ntre ghilimele
    trebuie sÄƒ includÄƒ caractere escape, aÈ™a cum se aratÄƒ Ã®n exemplul urmÄƒtor:
</p>
<pre>
    <code>
        string columns = "Column 1\tColumn 2\tColumn 3";
        //AfiÈ™eazÄƒ: Column 1        Column 2        Column 3

        string rows = "Row 1\r\nRow 2\r\nRow 3";
        /* AfiÈ™eazÄƒ:
            Row 1
            Row 2
            Row 3
        */

        string title = "\"The \u00C6olean Harp\", by Samuel Taylor Coleridge";
        //AfiÈ™eazÄƒ "The Ã†olean Harp", by Samuel Taylor Coleridge
    </code>
</pre>

<h3>È˜iruri literale de caractere literale verbatim</h3>
<p>
    Literalii de È™iruri de caractere verbatim sunt mai convenabili pentru È™iruri de caractere cu mai multe
    linii, È™iruri care conÈ›in caractere backslash sau ghilimele duble Ã®nglobate. È˜irurile Verbatim pÄƒstreazÄƒ
    caracterele de linie nouÄƒ ca parte a textului È™irului. UtilizaÈ›i ghilimele duble pentru a Ã®ncorpora un
    ghilimele Ã®n interiorul unui È™ir verbatim. Exemplul urmÄƒtor prezintÄƒ cÃ¢teva utilizÄƒri comune pentru
    È™irurile verbatim:
</p>
<pre>
    <code>
        string title = "\"The \u00C6olean Harp\", by Samuel Taylor Coleridge";
        //AfiÈ™eazÄƒ "The Ã†olean Harp", by Samuel Taylor Coleridge

        string filePath = @"C:\Users\scoleridge\Documents\";
        //AfiÈ™eazÄƒ C:\Users\scoleridge\Documents\

        string text = @"My pensive SARA ! thy soft cheek reclined
            Thus on mine arm, most soothing sweet it is
            To sit beside our Cot,...";
        /* AfiÈ™eazÄƒ:
        My pensive SARA ! thy soft cheek reclined
            Thus on mine arm, most soothing sweet it is
            To sit beside our Cot,...
        */

        string quote = @"Her name was ""Sara.""";
        //AfiÈ™eazÄƒ: Her name was "Sara."
    </code>
</pre>

<h3>È˜iruri literale brute</h3>
<p>
    ÃncepÃ¢nd cu C# 11, puteÈ›i utiliza literali de È™iruri de caractere brute pentru a crea mai uÈ™or È™iruri de
    caractere cu mai multe linii sau pentru a utiliza orice caractere care necesitÄƒ escape. Literalii de
    È™iruri brute eliminÄƒ necesitatea de a utiliza vreodatÄƒ secvenÈ›e escape. PuteÈ›i scrie È™irul, inclusiv
    formatarea spaÈ›iilor albe, aÈ™a cum doriÈ›i sÄƒ aparÄƒ la ieÈ™ire. Un literal de È™ir de caractere brut:
</p>
<ul>
    <li>
        Ãncepe È™i se terminÄƒ cu o secvenÈ›Äƒ de cel puÈ›in trei caractere de ghilimele duble (<code>"""</code>).
        Sunt permise mai mult de trei caractere consecutive pentru a Ã®ncepe È™i a termina secvenÈ›a, pentru a
        putea accepta È™iruri literale care conÈ›in trei (sau mai multe) caractere de ghilimele repetate.
    </li>
    <li>
        Literalii de È™iruri de caractere brute pe o singurÄƒ linie necesitÄƒ caracterele de deschidere È™i
        Ã®nchidere a ghilimelelor pe aceeaÈ™i linie.
    </li>
    <li>
        Literalii de È™iruri de caractere brute pe mai multe rÃ¢nduri necesitÄƒ atÃ¢t caracterele de deschidere, cÃ¢t
        È™i cele de Ã®nchidere a ghilimelelor pe propria linie.
    </li>
    <li>
        Ãn cazul literalilor de È™iruri de caractere brute pe mai multe rÃ¢nduri, orice spaÈ›iu alb din stÃ¢nga
        ghilimelelor de Ã®nchidere este eliminat din toate rÃ¢ndurile literalului de È™ir brut.
    </li>
    <li>
        Ãn cazul È™irurilor de caractere brute pe mai multe rÃ¢nduri, spaÈ›iile albe care urmeazÄƒ ghilimelelor de
        deschidere pe aceeaÈ™i linie sunt ignorate.
    </li>
    <li>
        Ãn cazul literalelor de È™iruri de caractere brute pe mai multe rÃ¢nduri, Ã®n literalul de È™ir sunt incluse
        numai liniile de spaÈ›iu alb care urmeazÄƒ ghilimelelor de deschidere.
    </li>
</ul>
<p>
    UrmÄƒtoarele exemple demonstreazÄƒ aceste reguli:
</p>
<pre>
    <code>
        string singleLine = """Friends say "hello" as they pass by.""";
        string multiLine = """
            "Hello World!" is typically the first program someone writes.
            """;
        string embeddedXML = """
            &ltelement attr = "content"&gt
                &ltody style="normal"&gt
                    Here is the main text
                &lt/body&gt
                &ltfooter&gt
                    Excerpts from "An amazing story"
                &lt/footer&gt
            &lt/element&gt
            """;
        // Linia "&ltelement attr = "content"&gt" Ã®ncepe Ã®n prima coloanÄƒ.
        // Toate spaÈ›iile albe din stÃ¢nga acestei coloane sunt eliminate din È™ir.

        string rawStringLiteralDelimiter = """"
            È˜irurile literale brute sunt delimitate 
            de un È™ir de cel puÈ›in trei ghilimele duble,
            astfel: """
            """";
    </code>
</pre>
<p>UrmÄƒtoarele exemple demonstreazÄƒ erorile de compilare semnalate pe baza acestor reguli:</p>
<pre>
    <code>
        // CS8997: Literal de È™ir de caractere brut nefinalizat.
        var multiLineStart = """This
            is the beginning of a string 
            """;

        // CS9000: Delimitatorul literalului de È™ir brut trebuie sÄƒ fie pe propria linie.
        var multiLineEnd = """
            This is the beginning of a string """;

        // CS8999: Linia nu Ã®ncepe cu acelaÈ™i spaÈ›iu alb ca È™i linia de Ã®nchidere
        // a literalului de È™ir brut.
        var noOutdenting = """
            A line of text.
        Trying to outdent the second line.
            """;
    </code>
</pre>
<p>
    Primele douÄƒ exemple nu sunt valide deoarece literalele de È™iruri de caractere brute pe mai multe linii
    necesitÄƒ o secvenÈ›Äƒ de ghilimele de deschidere È™i Ã®nchidere pe propria linie. Cel de-al treilea exemplu
    nu este valid deoarece textul este deplasat faÈ›Äƒ de secvenÈ›a de ghilimele de Ã®nchidere.
</p>
<p>
    Ar trebui sÄƒ luaÈ›i Ã®n considerare utilizarea de literali de È™iruri brute atunci cÃ¢nd generaÈ›i text care
    include caractere ce necesitÄƒ secvenÈ›e escape atunci cÃ¢nd utilizaÈ›i literali de È™iruri cotate sau literali
    de È™iruri verbatim. È˜irurile literale brute de caractere vor fi mai uÈ™or de citit pentru dvs. È™i pentru
    alte persoane, deoarece se vor asemÄƒna mai mult cu textul de ieÈ™ire. De exemplu, sÄƒ luÄƒm Ã®n considerare
    urmÄƒtorul cod care include un È™ir de caractere JSON formatat:
</p>
<pre>
    <code>
        string jsonString = """
        {
        "Date": "2019-08-01T00:00:00-07:00",
        "TemperatureCelsius": 25,
        "Summary": "Hot",
        "DatesAvailable": [
            "2019-08-01T00:00:00-07:00",
            "2019-08-02T00:00:00-07:00"
        ],
        "TemperatureRanges": {
            "Cold": {
            "High": 20,
            "Low": -10
            },
            "Hot": {
            "High": 60,
            "Low": 20
            }
                    },
        "SummaryWords": [
            "Cool",
            "Windy",
            "Humid"
        ]
        }
        """;
    </code>
</pre>

<h3>SecvenÈ›e escape a È™irurilor de caractere</h3>
<table>
    <thead>
        <tr>
            <th>SecvenÈ›Äƒ escape</th>
            <th>Denumire caracter</th>
            <th>Codificarea Unicode</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>\'</td>
            <td>Ghilimea simplÄƒ</td>
            <td>0x0027</td>
        </tr>    
        <tr>
            <td>\"</td>
            <td>Ghilimea dublÄƒ</td>
            <td>0x0022</td>
        </tr>
        <tr>
            <td>\\</td>
            <td>BarÄƒ oblicÄƒ inversÄƒ</td>
            <td>0x005C</td>
        </tr>
        <tr>
            <td>\0</td>
            <td>Null</td>
            <td>0x0000</td>
        </tr>
        <tr>
            <td>\a</td>
            <td>AlertÄƒ</td>
            <td>0x0007</td>
        </tr>
        <tr>
            <td>\b</td>
            <td>Backspace</td>
            <td>0x0008</td>
        </tr>
        <tr>
            <td>\f</td>
            <td>Form feed</td>
            <td>0x000C</td>
        </tr>
        <tr>
            <td>\n</td>
            <td>New line</td>
            <td>0x000A</td>
        </tr>
        <tr>
            <td>\r</td>
            <td>Carriage return</td>
            <td>0x000D</td>
        </tr>
        <tr>
            <td>\t</td>
            <td>Tab orizontal</td>
            <td>0x0009</td>
        </tr>
        <tr>
            <td>\v</td>
            <td>Tab vertical</td>
            <td>0x000B</td>
        </tr>
        <tr>
            <td>\u</td>
            <td>SecvenÈ›Äƒ escape Unicode (UTF-16)</td>
            <td><code>\uHHHH</code> (range: 0000 - FFFF; example: <code>\u00E7</code> = "Ã§")</td>
        </tr>
        <tr>
            <td>\U</td>
            <td>SecvenÈ›Äƒ escape Unicode (UTF-32)</td>
            <td><code>\U00HHHHHH</code> (range: 000000 - 10FFFF; example: <code>\U0001F47D</code> = "ğŸ‘½")</td>
        </tr>
        <tr>
            <td>\x</td>
            <td>SecvenÈ›Äƒ escape Unicode similarÄƒ cu "\u", Ã®nsÄƒ de lungime variabilÄƒ</td>
            <td><code>\xH[H][H][H]</code> (range: 0 - FFFF; example: <code>\x00E7</code> or <code>\x0E7</code> or <code>\xE7</code> = "Ã§")</td>
        </tr>
    </tbody>
</table>

<h6>AtenÈ›ie</h6>
<p>
    Atunci cÃ¢nd se utilizeazÄƒ secvenÈ›a escape <code>\x</code> È™i se specificÄƒ mai puÈ›in de 4 cifre hexazecimale,
    Ã®n cazul Ã®n care caracterele care urmeazÄƒ imediat dupÄƒ secvenÈ›a escape sunt cifre hexazecimale valide (de
    exemplu, 0-9, A-F È™i a-f), acestea vor fi interpretate ca fÄƒcÃ¢nd parte din secvenÈ›a escape. De exemplu,
    <code>\xA1</code> produce "Â¡", care este punctul de cod U+00A1. Cu toate acestea, dacÄƒ urmÄƒtorul caracter
    este "A" sau "a", atunci secvenÈ›a de evadare va fi interpretatÄƒ ca fiind <code>\xA1A</code> È™i va produce
    "à¨š", care este punctul de cod U+0A1A. Ãn astfel de cazuri, specificarea tuturor celor 4 cifre hexagonale
    (de exemplu, <code>\x00A1</code>) va preveni orice posibilÄƒ interpretare greÈ™itÄƒ.
</p>

<h6>NotÄƒ</h6>
<p>
    La momentul compilÄƒrii, È™irurile verbatim È™i cele brute sunt convertite Ã®n È™iruri de caractere obiÈ™nuite
    cu aceleaÈ™i secvenÈ›e escape. Prin urmare, dacÄƒ vizualizaÈ›i un È™ir verbatim sau brut Ã®n fereastra de
    supraveghere a depanatorului, veÈ›i vedea caracterele escape care au fost adÄƒugate de compilator, nu
    versiunea verbatim sau brutÄƒ din codul sursÄƒ. De exemplu, È™irul verbatim <code>@"C:\files.txt"</code> va
    apÄƒrea Ã®n fereastra de supraveghere ca "C:\files.txt".
</p>

<h3>È˜iruri de caractere formatate</h3>
<p>
    Un È™ir de caractere formatat este un È™ir de caractere al cÄƒrui conÈ›inut este determinat Ã®n mod dinamic Ã®n
    momentul execuÈ›iei. Aceste È™iruri sunt create prin Ã®ncorporarea expresiilor interpolate sau a caracterelor
    de poziÈ›ie (placeholders) Ã®n interiorul unor paranteze Ã®ntr-un È™ir. Tot ceea ce se aflÄƒ Ã®n interiorul parantezelor
    (<code>{...}</code>) va fi transformat Ã®ntr-o valoare È™i va fi emis ca È™ir formatat la momentul execuÈ›iei.
    ExistÄƒ douÄƒ metode de creare a È™irurilor formatate: interpolarea È™irurilor È™i formatarea compozitÄƒ.
</p>
<h4>Interpolarea È™irurilor de caractere</h4>
<p>
    È˜irurile interpolate sunt identificate prin caracterul special <code>$</code> È™i includ expresii interpolate
    Ã®ntre paranteze.
</p>
<p>
    UtilizaÈ›i interpolarea È™irurilor de caractere pentru a Ã®mbunÄƒtÄƒÈ›i lizibilitatea È™i a uÈ™ura Ã®ntreÈ›inerea
    codului dumneavoastrÄƒ. Interpolarea È™irurilor de caractere obÈ›ine aceleaÈ™i rezultate ca È™i metoda 
    <code>String.Format</code>, dar simplificÄƒ utilizarea È™i Ã®mbunÄƒtÄƒÈ›eÈ™te claritatea codului.
</p>
<pre>
    <code>
        var jh = (firstName: "Jupiter", lastName: "Hammon", born: 1711, published: 1761);
        Console.WriteLine($"{jh.firstName} {jh.lastName} was an African American poet born in {jh.born}.");
        Console.WriteLine($"He was first published in {jh.published} at the age of {jh.published - jh.born}.");
        Console.WriteLine($"He'd be over {Math.Round((2018d - jh.born) / 100d) * 100d} years old today.");

        // AfiÈ™eazÄƒ:
        // Jupiter Hammon was an African American poet born in 1711.
        // He was first published in 1761 at the age of 50.
        // He'd be over 300 years old today.
    </code>
</pre>
<p>
    ÃncepÃ¢nd cu C#10, puteÈ›i utiliza interpolarea È™irurilor de caractere pentru a iniÈ›ializa un È™ir constant
    atunci cÃ¢nd toate expresiile utilizate pentru caractere de poziÈ›ie sunt, de asemenea, È™iruri constante.
</p>
<p>
    ÃncepÃ¢nd cu C#11, puteÈ›i combina literali de È™iruri brute cu interpolÄƒri de È™iruri. Se Ã®ncepe È™i se terminÄƒ
    È™irul de format prin trei sau mai multe ghilimele duble succesive. DacÄƒ È™irul de ieÈ™ire trebuie sÄƒ conÈ›inÄƒ
    caracterul <code>{</code> sau <code>}</code>, puteÈ›i utiliza caractere <code>$</code> suplimentare pentru
    a specifica cÃ¢te caractere <code>{</code> È™i <code>}</code> Ã®ncep È™i terminÄƒ o interpolare. Orice secvenÈ›Äƒ
    cu mai puÈ›ine caractere <code>{</code> sau <code>}</code> este inclusÄƒ Ã®n ieÈ™ire. Exemplul urmÄƒtor aratÄƒ
    cum puteÈ›i utiliza aceastÄƒ caracteristicÄƒ pentru a afiÈ™a distanÈ›a unui punct faÈ›Äƒ de origine È™i pentru a
    plasa punctul Ã®n interiorul acoladelor:
</p>
<pre>
    <code>
        int X = 2;
        int Y = 3;

        var pointMessage = $$"""The point {{{X}}, {{Y}}} is {{Math.Sqrt(X * X + Y * Y)}} from the origin.""";

        Console.WriteLine(pointMessage);
        // AfiÈ™eazÄƒ:
        // The point {2, 3} is 3.605551275463989 from the origin.
    </code>
</pre>

<h4>Interpolarea È™irurilor de caractere verbatim</h4>
<p>
    C# permite, de asemenea, interpolarea textualÄƒ a È™irurilor de caractere, de exemplu pe mai multe linii,
    utilizÃ¢nd sintaxa <code>$@</code> sau <code>@$</code>.
</p>
<p>
    Pentru a interpreta secvenÈ›ele escape Ã®n mod literal, utilizaÈ›i un literal de È™ir de caractere literale.
    Un È™ir literar interpolat Ã®ncepe cu caracterul <code>$</code>  urmat de caracterul <code>@</code>. PuteÈ›i
    utiliza simbolurile <code>$</code>  È™i <code>@</code>  Ã®n orice ordine: atÃ¢t <code>$@"..."</code>, cÃ¢t È™i
    <code>@$"..."</code> sunt È™iruri verbatim interpolate valide.
</p>
<pre>
    <code>
        var jh = (firstName: "Jupiter", lastName: "Hammon", born: 1711, published: 1761);
        Console.WriteLine($@"{jh.firstName} {jh.lastName}
            was an African American poet born in {jh.born}.");
        Console.WriteLine(@$"He was first published in {jh.published}
        at the age of {jh.published - jh.born}.");

        // AfiÈ™eazÄƒ:
        // Jupiter Hammon
        //     was an African American poet born in 1711.
        // He was first published in 1761
        // at the age of 50.
    </code>
</pre>

<h4>Formatarea compozitÄƒ</h4>
<p>
    <code>String.Format</code> utilizeazÄƒ spaÈ›ii libere Ã®ntre paranteze pentru a crea un È™ir de formatat.
    Acest exemplu are ca rezultat o ieÈ™ire similarÄƒ cu metoda de interpolare a È™irurilor de caractere utilizatÄƒ mai sus.
</p>
<pre>
    <code>
        var pw = (firstName: "Phillis", lastName: "Wheatley", born: 1753, published: 1773);
        Console.WriteLine("{0} {1} was an African American poet born in {2}.", pw.firstName, pw.lastName, pw.born);
        Console.WriteLine("She was first published in {0} at the age of {1}.", pw.published, pw.published - pw.born);
        Console.WriteLine("She'd be over {0} years old today.", Math.Round((2018d - pw.born) / 100d) * 100d);

        // AfiÈ™eazÄƒ:
        // Phillis Wheatley was an African American poet born in 1753.
        // She was first published in 1773 at the age of 20.
        // She'd be over 300 years old today.
    </code>
</pre>

<h3>SubÈ™iruri</h3>
<p>
    O subÈ™ir este orice secvenÈ›Äƒ de caractere conÈ›inutÄƒ Ã®ntr-un È™ir de caractere. UtilizaÈ›i metoda <code>Substring</code>
    pentru a crea un nou È™ir de caractere dintr-o porÈ›iune a È™irului original. PuteÈ›i cÄƒuta una sau mai multe
    apariÈ›ii ale unui subÈ™ir, folosind metoda IndexOf. UtilizaÈ›i metoda <code>Replace</code> pentru a Ã®nlocui
    toate apariÈ›iile unui subÈ™ir specificat cu un nou È™ir. Ca È™i metoda <code>Substring</code>, <code>Replace</code>
    returneazÄƒ de fapt un nou È™ir de caractere È™i nu modificÄƒ È™irul original.
</p>
<pre>
    <code>
        string s3 = "Visual C# Express";
        System.Console.WriteLine(s3.Substring(7, 2));
        // AfiÈ™eazÄƒ: "C#"

        System.Console.WriteLine(s3.Replace("C#", "Basic"));
        // AfiÈ™eazÄƒ: "Visual Basic Express"

        // Valorile indecÈ™ilor pornesc de la 0
        int index = s3.IndexOf("C");
        // index = 7
    </code>
</pre>
<h3>Accesarea caracterelor individuale</h3>
<p>
    PuteÈ›i utiliza notaÈ›ia de tip vector cu o valoare de index pentru a obÈ›ine acces read-only la caractere
    individuale, ca Ã®n exemplul urmÄƒtor:
</p>
<pre>
    <code>
        string s5 = "Printing backwards";

        for (int i = 0; i < s5.Length; i++)
        {
            System.Console.Write(s5[s5.Length - i - 1]);
        }
        // AfiÈ™eazÄƒ: "sdrawkcab gnitnirP"
    </code>
</pre>
<p>
    Ãn cazul Ã®n care metodele <code>String</code> nu oferÄƒ funcÈ›ionalitatea necesarÄƒ pentru a schmba caracterele
    individuale dintr-un È™ir de caractere, puteÈ›i utiliza un obiect <code>StringBuilder</code> pentru a schimba
    caracterele individuale "la faÈ›a locului" È™i apoi sÄƒ creaÈ›i un nou È™ir de caractere pentru a stoca rezultatele
    prin utilizarea metodelor <code>StringBuilder</code>. Ãn exemplul urmÄƒtor, presupunem cÄƒ trebuie sÄƒ modificaÈ›i
    È™irul original Ã®ntr-un anumit mod È™i apoi sÄƒ stocaÈ›i rezultatele pentru utilizare ulterioarÄƒ:
</p>
<pre>
    <code>
        string question = "hOW DOES mICROSOFT wORD DEAL WITH THE cAPS lOCK KEY?";
        System.Text.StringBuilder sb = new System.Text.StringBuilder(question);

        for (int j = 0; j < sb.Length; j++)
        {
            if (System.Char.IsLower(sb[j]) == true)
                sb[j] = System.Char.ToUpper(sb[j]);
            else if (System.Char.IsUpper(sb[j]) == true)
                sb[j] = System.Char.ToLower(sb[j]);
        }
        // StocheazÄƒ noul È™ir de caractere.
        string corrected = sb.ToString();
        System.Console.WriteLine(corrected);
        // AfiÈ™eazÄƒ: How does Microsoft Word deal with the Caps Lock key?
    </code>
</pre>

<h3>È˜iruri nule È™i È™iruri vide</h3>
<p>
    Un È™ir vid este o instanÈ›Äƒ a unui obiect <code>System.String</code> care conÈ›ine zero caractere. È˜irurile
    vide sunt utilizate adesea Ã®n diverse scenarii de programare pentru a reprezenta un cÃ¢mp de text gol. PuteÈ›i
    apela metode pe È™iruri goale deoarece acestea sunt obiecte <code>System.String</code> valide. È˜irurile vide
    sunt iniÈ›ializate dupÄƒ cum urmeazÄƒ:
</p>
<pre>
    <code>
        string s = String.Empty;
    </code>
</pre>
<p>
    Ãn schimb, un È™ir de caractere nul nu se referÄƒ la o instanÈ›Äƒ a unui obiect <code>System.String</code> È™i
    orice Ã®ncercare de a apela o metodÄƒ pe un È™ir de caractere nul provoacÄƒ o excepÈ›ie <code>NullReferenceException</code>.
    Cu toate acestea, puteÈ›i utiliza È™iruri de caractere nule Ã®n operaÈ›iile de concatenare È™i comparare cu
    alte È™iruri de caractere. Exemplele urmÄƒtoare ilustreazÄƒ cÃ¢teva cazuri Ã®n care o referinÈ›Äƒ la un È™ir de
    caractere nul provoacÄƒ sau nu o excepÈ›ie:
</p>
<pre>
    <code>
        string str = "hello";
        string nullStr = null;
        string emptyStr = String.Empty;

        string tempStr = str + nullStr;
        // Linia de mai jos tipÄƒreÈ™te: hello
        Console.WriteLine(tempStr);

        bool b = (emptyStr == nullStr);
        // Linia de mai jos tipÄƒreÈ™te: False
        Console.WriteLine(b);

        // UrmÄƒtoarea linie creeazÄƒ un È™ir de caractere vid.
        string newStr = emptyStr + nullStr;

        // È˜irurile nule se comportÄƒ diferit. UrmÄƒtoarele douÄƒ linii afiÈ™eazÄƒ 0
        Console.WriteLine(emptyStr.Length);
        Console.WriteLine(newStr.Length);
        // UrmÄƒtoarea linie cauzeazÄƒ o eroare de tipul NullReferenceException.
        //Console.WriteLine(nullStr.Length);

        // Caracterul null poate fi afiÈ™at È™i numÄƒrat ca orice alt caracter.
        string s1 = "\x0" + "abc";
        string s2 = "abc" + "\x0";
        // Linia de mai jos tipÄƒreÈ™te: * abc*
        Console.WriteLine("*" + s1 + "*");
        // Linia de mai jos tipÄƒreÈ™te: *abc *
        Console.WriteLine("*" + s2 + "*");
        // Linia de mai jos tipÄƒreÈ™te: 4
        Console.WriteLine(s2.Length);
    </code>
</pre>

<h3>Folosirea stringBuilder pentru crearea rapidÄƒ a È™irurilor de caractere</h3>
<p>
    OperaÈ›iile cu È™iruri de caractere Ã®n .NET sunt foarte optimizate È™i, Ã®n majoritatea cazurilor, nu au un
    impact semnificativ asupra performanÈ›ei. Cu toate acestea, Ã®n anumite scenarii, cum ar fi buclele strÃ¢nse
    care se executÄƒ de mai multe sute sau mii de ori, operaÈ›iunile cu È™iruri de caractere pot afecta performanÈ›a.
    Clasa <code>StringBuilder</code> creeazÄƒ un buffer de È™iruri de caractere care oferÄƒ o performanÈ›Äƒ mai
    bunÄƒ dacÄƒ programul dumneavoastrÄƒ efectueazÄƒ multe manipulÄƒri de È™iruri de caractere. È˜irul <code>StringBuilder</code>
    vÄƒ oferÄƒ, de asemenea, posibilitatea de a realoca caractere individuale, aspect pe care tipul de date
    string Ã®ncorporat nu Ã®l permite. Acest cod, de exemplu, modificÄƒ conÈ›inutul unui È™ir de caractere fÄƒrÄƒ a
    crea un nou È™ir de caractere:
</p>
<pre>
    <code>
        System.Text.StringBuilder sb = new System.Text.StringBuilder("Rat: the ideal pet");
        sb[0] = 'C';
        System.Console.WriteLine(sb.ToString());
        // TipÄƒreÈ™te Cat: the ideal pet
    </code>
</pre>
<p>
    Ãn acest exemplu, un obiect <code>StringBuilder</code> este utilizat pentru a crea un È™ir de caractere
    dintr-un set de tipuri numerice:
</p>
<pre>
    <code>
        var sb = new StringBuilder();

        // CreeazÄƒ un È™ir de caractere compus din cifrele 0 - 9
        for (int i = 0; i &lt 10; i++)
        {
            sb.Append(i.ToString());
        }
        Console.WriteLine(sb);  // afiÈ™eazÄƒ 0123456789

        // CopiazÄƒ un caracter din È™ir (operaÈ›ie imposibilÄƒ cu System.String)
        sb[0] = sb[9];

        Console.WriteLine(sb);  // afiÈ™eazÄƒ 9123456789
    </code>
</pre>

<h3>È˜iruri de caractere, metode de extensie È™i LINQ</h3>
<p>
    Deoarece tipul String implementeazÄƒ <code>IEnumerable&ltT&gt</code>, puteÈ›i utiliza metodele de extensie
    definite Ã®n clasa <code>Enumerable</code> pentru È™irurile de caractere. Pentru a evita dezordinea vizualÄƒ,
    aceste metode sunt excluse din IntelliSense pentru tipul <code>String</code>, dar ele sunt totuÈ™i disponibile.
    De asemenea, puteÈ›i utiliza expresii de interogare LINQ pe È™iruri de caractere.
</p>