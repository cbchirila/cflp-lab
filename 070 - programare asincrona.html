
<h1>Programare asincrona</h1>
<div>
<h2>7.1 Async si await</h2>

<p>Solicitarea datelor dintr-o rețea, accesarea unei baze de date sau citirea și scrierea într-un sistem de fișiere, necesită utilizarea programării asincrone. De asemenea, puteți avea cod legat de procesor, cum ar fi efectuarea unui calcul scump, care este, de asemenea, un scenariu bun pentru scrierea de cod asincron.</p>
	<p>C# are un model de programare asincronă la nivel de limbaj, care permite scrierea ușoară a codului asincron fără a fi nevoie să manevreze apelurile înapoi sau să se conformeze unei biblioteci care susține asincronia. Urmează ceea ce se numește Modelul de Asincronizare bazat pe Sarcini (TAP).</p>
	<h3><b>Prezentarea generală a modelului asincron</b></h3>
	<p>Baza programării asincrone o reprezintă obiectele Task și Task&lt;T&gt;, care modelează operațiile asincrone. Acestea sunt acceptate de cuvintele cheie async și await. Modelul este destul de simplu în majoritatea cazurilor:</p>
	<ol>
		<li>Pentru codul legat de I/O, așteptați o operație care returnează un Task sau Task&lt;T&gt; într-un metoda async.</li>
		<li>Pentru codul legat de procesor, așteptați o operație care este pornită pe un fir de fundal cu metoda Task.Run.</li>
	</ol>
	<p>Cuvântul cheie await este locul unde se întâmplă magia. Acesta cedează controlul apelantului metodei care a efectuat așteptarea și permite în cele din urmă o interfață utilizator sau un serviciu să fie receptiv. Deși există modalități de abordare a codului asincron în afara de async și await, acest articol se concentrează pe construcțiile la nivel de limbaj.</p>

 <h3><b>Exemplu legat de I/O: Descărcarea datelor dintr-un serviciu web</b></h3>
	<p>Poate fi necesar să descărcați unele date dintr-un serviciu web atunci când se apasă un buton, dar nu doriți să blocați firul de interfață utilizator. Acest lucru poate fi realizat astfel, utilizând clasa System.Net.Http.HttpClient:</p>
	<div>
		<pre>
<code>private readonly HttpClient _httpClient = new HttpClient();
downloadButton.Clicked += async (o, e) =>
{
// This line will yield control to the UI as the request
// from the web service is happening.
//
// The UI thread is now free to perform other work.
var stringData = await _httpClient.GetStringAsync(URL);
DoSomethingWithData(stringData);
};</code>
</pre>
</div>
<p>Codul exprimă intenția (descărcarea datelor în mod asincron) fără a se bloca în interacțiunea cu obiectele Task.</p>

<h3><b>Exemplu legat de CPU: Efectuarea unui calcul pentru un joc</b></h3>
	<p>Să spunem că scrieți un joc mobil în care apăsarea unui buton poate cauza daune la mai mulți inamici de pe ecran. Efectuarea calculelor poate fi costisitoare, iar dacă se efectuează pe firul de interfață utilizator, jocul va părea să se oprească în timp ce se efectuează calculele!</p>
	<p>Cel mai bun mod de a gestiona aceasta este de a începe un fir de execuție de fundal, care efectuează lucrul folosind Task.Run și așteaptă rezultatul său folosind await. Acest lucru permite interfeței de utilizator să fie netedă în timp ce lucrul este efectuat.</p>
	<div>
		<pre>
<code>private DamageResult CalculateDamageDone()
{
    // Code omitted:
    //
    // Does an expensive calculation and returns
    // the result of that calculation.
}
calculateButton.Clicked += async (o, e) =>
{
// This line will yield control to the UI while CalculateDamageDone()
// performs its work. The UI thread is free to perform other work.
var damageResult = await Task.Run(() => CalculateDamageDone());
DisplayDamage(damageResult);
};</code>
</pre>
</div>
<p>Acest cod exprimă clar intenția evenimentului de clic al butonului, nu necesită gestionarea manuală a unui fir de execuție de fundal și o face într-un mod non-blocant.</p>

<h3>Puncte cheie pentru a înțelege:</h3>

<p>Codul asincron poate fi utilizat atât pentru cod legat de I/O, cât și pentru cel legat de procesor, dar în mod diferit pentru fiecare scenariu.</p>

<p>Codul asincron utilizează <code>Task&lt;T&gt;</code> și <code>Task</code>, care sunt construcții utilizate pentru a modela lucrul care se face în fundal.</p>

<p>Cuvântul cheie <code>async</code> transformă o metodă într-o metodă asincronă, ceea ce vă permite să utilizați cuvântul cheie <code>await</code> în corpul acesteia.</p>

<p>Atunci când este aplicat cuvântul cheie <code>await</code>, acesta suspendă apelul metodei și oferă controlul înapoi apelantului său până când sarcina așteptată este finalizată.</p>

<p><code>await</code> poate fi utilizat doar în interiorul unei metode asincrone.</p>

<h3>Recunoașterea lucrului legat de procesor și cel legat de I/O</h3>

<p>Primele două exemple din acest ghid arată cum puteți utiliza <code>async</code> și <code>await</code> pentru lucrul legat de I/O și de procesor. Este important să puteți identifica când o sarcină pe care trebuie să o efectuați este legată de I/O sau de procesor, deoarece acest lucru poate afecta semnificativ performanța codului și ar putea duce la utilizarea incorectă a anumitor construcții.</p>

<p>Iată două întrebări pe care ar trebui să le puneți înainte de a scrie cod:</p>

<ol>
  <li>Va "aștepta" codul dvs. ceva, cum ar fi date dintr-o bază de date?</li>
  <ul>
    <li>Dacă răspunsul este "da", atunci lucrul dvs. este legat de I/O.</li>
  </ul>
  <li>Va efectua codul dvs. o calculație costisitoare?</li>
  <ul>
    <li>Dacă ați răspuns "da", atunci lucrul dvs. este legat de procesor.</li>
  </ul>
</ol>

<p>Dacă sarcina pe care o aveți este legată de I/O, utilizați <code>async</code> și <code>await</code> fără <code>Task.Run</code>. Nu ar trebui să utilizați biblioteca paralelă de sarcini (<code>Task Parallel Library</code>).</p>

<p>Dacă sarcina pe care o aveți este legată de procesor și vă interesează reactivitatea, utilizați <code>async</code> și <code>await</code>, dar declanșați sarcina pe un alt fir cu <code>Task.Run</code>. Dacă sarcina este potrivită pentru concurență și paralelism, luați în considerare și utilizarea bibliotecii paralele de sarcini (<code>Task Parallel Library</code>).</p>

<p>În plus, ar trebui întotdeauna să măsurați execuția codului dvs. De exemplu, s-ar putea să vă aflați într-o situație în care lucrul dvs. legat de procesor nu este suficient de costisitor în comparație cu supraîncărcarea de comutare a contextului când se utilizează mai multe fire de execuție. Fiecare alegere are un compromis și ar trebui să alegeți compromisul corect pentru situația dvs.</p>

<h3>Informații importante și sfaturi</h3>
  <p>Cu programarea asincronă, există câteva detalii de ținut minte pentru a preveni comportamentul neașteptat.</p>
  <ul>
    <li>Metodele asincrone trebuie să aibă cuvântul cheie <code>await</code> în corpul lor, altfel nu vor da randament!</li>
    <li>Este important să țineți asta în minte. Dacă <code>await</code> nu este utilizat în corpul unei metode asincrone, compilatorul C# generează o atenționare, dar codul se compilează și rulează ca și cum ar fi o metodă normală. Acest lucru este extrem de ineficient, deoarece mașina de stare generată de compilatorul C# pentru metoda asincronă nu realizează nimic.</li>
    <li>Adăugați "<code>Async</code>" ca sufix pentru fiecare nume de metodă asincronă pe care o scrieți. Aceasta este convenția utilizată în .NET pentru a diferenția mai ușor metodele sincrone și asincrone. Anumite metode care nu sunt apelate explicit de codul dvs. (cum ar fi evenimentele sau metodele controlerului web) nu se aplică neapărat. Deoarece nu sunt apelate explicit de codul dvs., a fi explicit în privința denumirii lor nu este la fel de important.</li>
    <li><code>async void</code> ar trebui să fie folosit doar pentru gestionarii de evenimente. <code>async void</code> este singura modalitate de a permite gestionarilor de evenimente asincrone să funcționeze, deoarece evenimentele nu au tipuri de returnare (astfel nu pot folosi <code>Task</code> și <code>Task&lt;T&gt;</code>). Orice altă utilizare a <code>async void</code> nu urmează modelul TAP și poate fi dificil de utilizat, cum ar fi:</li>
    <ul>
      <li>Excepțiile aruncate într-o metodă <code>async void</code> nu pot fi prinse în afara acelei metode.</li>
      <li>Metodele <code>async void</code> sunt dificil de testat.</li>
      <li>Metodele <code>async void</code> pot cauza efecte secundare negative dacă apelantul nu se așteaptă să fie async.</li>
    </ul>
    <p>Fiți atenți atunci când utilizați lambda-uri asincrone în expresiile LINQ</p>
<p>Expresiile lambda în LINQ utilizează execuția amânată, ceea ce înseamnă că codul ar putea fi executat într-un moment în care nu vă așteptați. Introducerea sarcinilor blocante în acesta poate duce ușor la blocarea dacă nu este scris corect. În plus, încorporarea codului asincron în acest fel poate face și mai dificilă raționamentul despre execuția codului.</p>
</div>

<div>
<h2>7.2 Task asynchronous programming model</h2>
<p>Folosind programarea asincrona, puteti evita problemele de performanta si imbunatati reactia aplicatiei dumneavoastra. Cu toate acestea, tehniciile traditionale pentru scrierea de aplicatii asincrone pot fi complicate, ceea ce face dificila scrierea, depanarea si intretinerea lor.</p>
	<p>C# suporta o abordare simplificata, programarea asincrona, care utilizeaza suportul asincron din timpul de executie .NET. Compilatorul face munca dificila pe care dezvoltatorul o realiza inainte, iar aplicatia dumneavoastra pastreaza o structura logica care seamana cu codul sincron. In consecinta, beneficiati de toate avantajele programarii asincrone cu o fractiune din efortul anterior.</p>
	<p>Acest subiect ofera o prezentare generala a momentului si modului de utilizare a programarii asincrone si include link-uri catre subiecte de suport care contin detalii si exemple.</p>
    <p>Asincronia îmbunătățește responsivitatea</p>
<p>Asincronia este esențială pentru activitățile care pot fi blocate, cum ar fi accesul la web. Accesul la o resursă web poate fi uneori lent sau întârziat. Dacă o astfel de activitate este blocată într-un proces sincron, întreaga aplicație trebuie să aștepte. Într-un proces asincron, aplicația poate continua cu alte lucrări care nu depind de resursa web până când sarcina potențial blocantă se termină.</p>
<p>Asincronia este deosebit de valoroasă pentru aplicațiile care accesează firul UI deoarece toată activitatea legată de UI împărtășește în mod obișnuit un fir. Dacă orice proces este blocat într-o aplicație sincronă, toate sunt blocate. Aplicația dvs. nu mai răspunde și ați putea concluziona că a eșuat când de fapt doar așteaptă.</p>
<p>Atunci când utilizați metode asincrone, aplicația continuă să răspundă la interacțiunile cu UI-ul. Puteți redimensiona sau minimiza o fereastră, de exemplu, sau puteți închide aplicația dacă nu doriți să așteptați să se termine.</p>
<p>Abordarea bazată pe async adaugă echivalentul unei transmisii automate la lista de opțiuni pe care le puteți alege atunci când proiectați operațiuni asincrone. Adică beneficiați de toate avantajele programării asincrone tradiționale, dar cu mult mai puțin efort din partea dezvoltatorului.</p>

<p>Metodele Async sunt ușor de scris</p>
<p>Cuvintele cheie async și await în C# sunt inima programării asincrone. Folosind aceste două cuvinte cheie, puteți utiliza resursele din .NET Framework, .NET Core sau Windows Runtime pentru a crea o metodă asincronă aproape la fel de ușor ca și o metodă sincronă. Metodele asincrone pe care le definiți folosind cuvântul cheie async sunt denumite metode async.</p>

<p>Următorul exemplu arată o metodă async. Aproape totul din cod ar trebui să vă fie familiar.</p>

<p>Puteți găsi un exemplu complet de Windows Presentation Foundation (WPF) disponibil pentru descărcare de la <a href="https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/async/asynchronous-programming-with-async-and-await">Programarea asincronă cu async și await în C#</a>.</p>

<pre><code class="language-csharp">public async Task&lt;int&gt; GetUrlContentLengthAsync()
{
    var client = new HttpClient();

    Task&lt;string&gt; getStringTask =
        client.GetStringAsync("https://learn.microsoft.com/dotnet");

    DoIndependentWork();

    string contents = await getStringTask;

    return contents.Length;
}

void DoIndependentWork()
{
    Console.WriteLine("Working...");
}</code></pre>

<p>Puteți învăța mai multe practici din exemplul anterior. Începeți cu semnătura metodei. Aceasta include modificatorul async. Tipul de returnare este Task&lt;int&gt; (<a href="https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/async/how-to-define-a-return-type-for-an-async-method">Consultați secțiunea „Tipuri de returnare” pentru mai multe opțiuni</a>). Numele metodei se termină în Async. În corpul metodei, GetStringAsync returnează un Task&lt;string&gt;. Acest lucru înseamnă că, atunci când așteptați task-ul, veți obține un șir de caractere (conținuturi). Înainte de așteptarea task-ului, puteți efectua lucrări care nu depind de șirul de la GetStringAsync.</p>

<p>Acordați o atenție deosebită operatorului await. Aceasta suspendă GetUrlContentLengthAsync:</p>

<ul>
  <li>GetUrlContentLengthAsync nu poate continua până când getStringTask este complet.</li>
  <li>Între timp, controlul se întoarce la apelantul lui GetUrlContentLengthAsync.</li>
  <li>Controlul se reia aici când getStringTask este complet.</li>
  <li>Operatorul await apoi recuperează rezultatul sub forma unui șir de caractere din getStringTask.</li>
</ul>

<p>Instrucțiunea return specifică un rezultat întreg. Orice metode care așteaptă GetUrlContentLengthAsync vor recupera valoarea lungimii.</p>

<h3>Tipuri de returnare și parametri</h3>
<p>De obicei, o metodă async returnează un Task sau un Task&lt;TResult&gt;. În interiorul unei metode async, operatorul await se aplică la un Task returnat dintr-un apel la o altă metodă async.</p>
<p>Specificați Task&lt;TResult&gt; ca tipul de returnare dacă metoda conține o instrucțiune return care specifică un operand de tip TResult.</p>
<p>Folosiți Task ca tipul de returnare dacă metoda nu are o instrucțiune return sau are o instrucțiune return care nu returnează un operand.</p>
<p>Puteți specifica și orice alt tip de returnare, cu condiția ca tipul să includă o metodă GetAwaiter. ValueTask&lt;TResult&gt; este un exemplu de astfel de tip. Este disponibil în pachetul NuGet System.Threading.Tasks.Extension.</p>
<p>Următorul exemplu arată cum declarați și apelați o metodă care returnează un Task&lt;TResult&gt; sau un Task:</p>
<pre><code class="lang-csharp">async Task&lt;int&gt; GetTaskOfTResultAsync()
{
    int hours = 0;
    await Task.Delay(0);

    return hours;
}


Task&lt;int&gt; returnedTaskTResult = GetTaskOfTResultAsync();
int intResult = await returnedTaskTResult;
// Single line
// int intResult = await GetTaskOfTResultAsync();

async Task GetTaskAsync()
{
    await Task.Delay(0);
    // No return statement needed
}

Task returnedTask = GetTaskAsync();
await returnedTask;
// Single line
await GetTaskAsync();</code></pre>
<p>Fiecare task returnat reprezintă o lucrare în desfășurare. Un task încapsulează informații despre starea procesului asincron și, în cele din urmă, fie rezultatul final al procesului, fie excepția pe care procesul o ridică dacă nu reușește.</p>
<p>O metodă async poate avea, de asemenea, un tip de returnare void. Acest tip de returnare este utilizat în principal pentru a defini manipulatoare de evenimente, unde un tip de returnare void este necesar. Manipulatoarele de evenimente asincrone servesc adesea ca punct de pornire pentru programele asincrone.</p>
<p>O metodă async cu un tip de returnare void nu poate fi așteptată, iar apelantul unei metode care returnează void nu poate captura nicio excepție pe care metoda o aruncă.</p>
<p>O metodă async nu poate declara parametri in, ref sau out, dar metoda poate apela metode care au astfel de parametri. Similar, o metodă async nu poate returna o valoare prin referință, deși poate apela metode cu valori returnate prin ref.</p>



</div>

<div>
<h2>7.3 Async return types</h2>

<pre>
Metodele asincrone pot avea următoarele tipuri de returnare:
<ul>
    <li><code>Task</code>, pentru o metodă asincronă care efectuează o operație, dar nu returnează niciun rezultat.</li>
    <li><code>Task&lt;TResult&gt;</code>, pentru o metodă asincronă care returnează o valoare.</li>
    <li><code>void</code>, pentru un manipulator de evenimente.</li>
    <li>Orice tip care are o metodă <code>GetAwaiter</code> accesibilă. Obiectul returnat de metoda <code>GetAwaiter</code> trebuie să implementeze interfața <code>System.Runtime.CompilerServices.ICriticalNotifyCompletion</code>.</li>
    <li><code>IAsyncEnumerable&lt;T&gt;</code>, pentru o metodă asincronă care returnează un flux asincron.</li>
</ul>
</pre>


<h3>Tipul de returnare Task</h3>

<p>Metodele asincrone care nu conțin o declarație de returnare sau care conțin o declarație de returnare care nu returnează un operand au de obicei un tip de returnare Task. Astfel de metode returnează void dacă rulează sincron. Dacă utilizați un tip de returnare Task pentru o metodă asincronă, o metodă apelată poate utiliza un operator await pentru a suspenda finalizarea apelantului până când metoda asincronă apelată se termină.</p>

<p>În exemplul următor, metoda WaitAndApologizeAsync nu conține o declarație de returnare, deci metoda returnează un obiect Task. Returnarea unui Task permite apelarea asincronă a metodei WaitAndApologizeAsync. Tipul Task nu include o proprietate Result deoarece nu are o valoare de returnat.</p>

<pre>
<code>
public static async Task DisplayCurrentInfoAsync()
{
    await WaitAndApologizeAsync();

    Console.WriteLine($"Astăzi este {DateTime.Now:D}");
    Console.WriteLine($"Ora curentă este {DateTime.Now.TimeOfDay:t}");
    Console.WriteLine("Temperatura curentă este de 76 de grade.");
}

static async Task WaitAndApologizeAsync()
{
    await Task.Delay(2000);

    Console.WriteLine("Îmi pare rău pentru întârziere...\n");
}
</code>
</pre>

<p>Metoda WaitAndApologizeAsync este așteptată folosind o instrucțiune await în loc de o expresie await, similar cu instrucțiunea de apel pentru o metodă de returnare sincronă. Aplicarea unui operator await în acest caz nu produce o valoare. Când operandul drept al unui await este un Task<TResult>, expresia await produce un rezultat de tip T. Când operandul drept al unui await este un Task, await și operandul său sunt o instrucțiune.</p>

<p>Puteți separa apelul metodei WaitAndApologizeAsync de aplicarea unui operator await, așa cum arată codul următor. Totuși, rețineți că un Task nu are o proprietate Result și că nu se produce nicio valoare atunci când se aplică un operator await la un Task.</p>

<h3>Tipul de returnare Task&lt;TResult&gt;</h3>
<p>
Tipul de returnare Task&lt;TResult&gt; este utilizat pentru o metodă async care conține o declarație return cu un operand TResult.
</p>
<p>
În exemplul de mai jos, metoda GetLeisureHoursAsync conține o declarație return care returnează un număr întreg. Declararea metodei trebuie să specifice un tip de returnare de Task&lt;int&gt;. Metoda async FromResult este un substituent pentru o operație care returnează o DayOfWeek.
</p>
<pre><code class="language-csharp">
public static async Task ShowTodaysInfoAsync()
{
    string message =
        $"Today is {DateTime.Today:D}\n" +
        "Today's hours of leisure: " +
        $"{await GetLeisureHoursAsync()}";

    Console.WriteLine(message);
}

static async Task&lt;int&gt; GetLeisureHoursAsync()
{
    DayOfWeek today = await Task.FromResult(DateTime.Now.DayOfWeek);

    int leisureHours =
        today is DayOfWeek.Saturday || today is DayOfWeek.Sunday
        ? 16 : 5;

    return leisureHours;
}
</code></pre>
<p>
Când GetLeisureHoursAsync este apelat dintr-o expresie await în metoda ShowTodaysInfo, expresia await recuperează valoarea întreagă (valoarea lui leisureHours) care este stocată în sarcina returnată de metoda GetLeisureHours. Pentru mai multe informații despre expresii await, consultați await.
</p>
<p>
Puteți înțelege mai bine modul în care await recuperează rezultatul dintr-un Task&lt;T&gt; prin separarea apelului la GetLeisureHoursAsync de aplicarea await, așa cum arată codul de mai jos. Un apel la metoda GetLeisureHoursAsync care nu este așteptată imediat returnează un Task&lt;int&gt;, așa cum v-ați aștepta din declarația metodei. Sarcina este atribuită variabilei getLeisureHoursTask în exemplul. Deoarece getLeisureHoursTask este un Task&lt;TResult&gt;, conține o proprietate Result de tip TResult. În acest caz, TResult reprezintă un tip întreg. Când await este aplicat la getLeisureHoursTask, expresia await evaluează la conținutul proprietății Result a getLeisureHoursTask. Valoarea este atribuită variabilei ret.
</p>

<h3>Tipul de returnare void</h3>
<p>
Folosiți tipul de returnare vid în handler-ele de evenimente asincrone, care necesită un tip de returnare vid. Pentru metodele care nu returnează o valoare, alte decât handler-ele de evenimente, ar trebui să returnați în schimb un Task, deoarece o metodă async care returnează vid nu poate fi așteptată. Orice apelant al unei astfel de metode trebuie să continue până la finalizare fără așteptarea finalizării metodei async apelate. Apelantul trebuie să fie independent de orice valori sau excepții generate de metoda async.
</p>
<p>
Apelantul unei metode async care returnează void nu poate prinde excepțiile aruncate din metoda respectivă. Astfel de excepții nemanipulate sunt susceptibile să cauzeze eșecul aplicației. Dacă o metodă care returnează un Task sau Task<TResult> aruncă o excepție, aceasta este stocată în task-ul returnat. Excepția este relansată atunci când task-ul este așteptat. Asigurați-vă că orice metodă async care poate produce o excepție are un tip de returnare de Task sau Task<TResult> și că apelurile către metoda respectivă sunt așteptate.
</p>
<p>
Următorul exemplu arată comportamentul unui handler de evenimente async. În codul de exemplu, un handler de evenimente async trebuie să-i informeze firul principal când acesta se termină. Apoi, firul principal poate aștepta ca un handler de evenimente async să se finalizeze înainte de a ieși din program.
</p>
<pre><code class="lang-csharp">public class NaiveButton
{
    public event EventHandler? Clicked;

    public void Click()
    {
        Console.WriteLine("Somebody has clicked a button. Let's raise the event...");
        Clicked?.Invoke(this, EventArgs.Empty);
        Console.WriteLine("All listeners are notified.");
    }
}

public class AsyncVoidExample
{
    static readonly TaskCompletionSource&lt;bool&gt; s_tcs = new TaskCompletionSource&lt;bool&gt;();

    public static async Task MultipleEventHandlersAsync()
    {
        Task&lt;bool&gt; secondHandlerFinished = s_tcs.Task;

        var button = new NaiveButton();

        button.Clicked += OnButtonClicked1;
        button.Clicked += OnButtonClicked2Async;
        button.Clicked += OnButtonClicked3;

        Console.WriteLine("Before button.Click() is called...");
        button.Click();
        Console.WriteLine("After button.Click() is called...");

        await secondHandlerFinished;
    }

    private static void OnButtonClicked1(object? sender, EventArgs e)
    {
        Console.WriteLine("   Handler 1 is starting...");
        Task.Delay(100).Wait();
        Console.WriteLine("   Handler 1 is done.");
    }

    private static async void OnButtonClicked2Async(object? sender, EventArgs e)
    {
        Console.WriteLine("   Handler 2 is starting...");
        Task.Delay(100).Wait();
        Console.WriteLine("   Handler 2 is about to go async...");
        await Task.Delay(500);
        Console.WriteLine("   Handler 2 is done.");
        s_tcs.SetResult(true);
    }

    private static void OnButtonClicked3(object? sender, EventArgs e)
    {
        Console.WriteLine("   Handler 3 is starting...");
        Task.Delay(100).Wait();
        Console.WriteLine("   Handler 3 is done.");
    }
}
// Example output:
//
// Before button.Click() is called...
// Somebody has clicked a button. Let's raise the event...
//    Handler 1 is starting...
//    Handler 1 is done.
//    Handler 2 is starting...
//    Handler 2 is about to go async...
//    Handler 3 is starting...
//    Handler 3 is done.
// All listeners are notified.
// After button.Click() is called...
//    Handler 2 is done.</code></pre>

<h3>Tipuri generalizate de returnare asincronă și ValueTask&lt;TResult&gt;</h3>
<p>O metodă asincronă poate returna orice tip care are o metodă GetAwaiter accesibilă, care returnează o instanță a unui tip așteptat. În plus, tipul returnat de metoda GetAwaiter trebuie să aibă atributul System.Runtime.CompilerServices.AsyncMethodBuilderAttribute. Puteți afla mai multe în <a href="https://docs.microsoft.com/dotnet/csharp/language-reference/compiler-options/attributes-that-control-runtime-behavior/asyncmethodbuilderattribute">articolul despre atribute citit de compilator</a> sau în <a href="https://github.com/dotnet/csharplang/blob/master/proposals/csharp-7.3/async-streams.md#value-task-based-asynchronous-streams">specificația de funcționalitate pentru tipurile de returnare de tip Task</a>.</p>
<p>Această funcționalitate este complementară cu expresiile așteptabile, care descriu cerințele pentru operandul de așteptare. Tipurile generalizate de returnare asincronă permit compilatorului să genereze metode asincrone care returnează diferite tipuri. Tipurile generalizate de returnare asincronă au permis îmbunătățiri de performanță în bibliotecile .NET. Deoarece Task și Task&lt;TResult&gt; sunt tipuri de referință, alocarea de memorie în căile de performanță critice, în special atunci când alocările apar în bucle strânse, poate afecta negativ performanța. Suportul pentru tipurile de returnare generalizate înseamnă că puteți returna un tip de valoare ușor în locul unui tip de referință pentru a evita alocările suplimentare de memorie.</p>
<p>.NET furnizează structura System.Threading.Tasks.ValueTask&lt;TResult&gt; ca o implementare ușoară a unei valori de returnare a sarcinilor generalizate. Pentru a utiliza tipul System.Threading.Tasks.ValueTask&lt;TResult&gt;, trebuie să adăugați pachetul NuGet System.Threading.Tasks.Extensions la proiectul dvs. Exemplul următor utilizează structura ValueTask&lt;TResult&gt; pentru a obține valoarea a două zaruri.</p>
<pre><code class="lang-csharp">class Program
{
    static readonly Random s_rnd = new Random();

    static async Task Main() =>
        Console.WriteLine("You rolled {await GetDiceRollAsync()}");

    static async ValueTask&lt;int&gt; GetDiceRollAsync()
    {
        Console.WriteLine("Shaking dice...");

        int roll1 = await RollAsync();
        int roll2 = await RollAsync();

        return roll1 + roll2;
    }

    static async ValueTask&lt;int&gt; RollAsync()
    {
        await Task.Delay(500);

        int diceRoll = s_rnd.Next(1, 7);
        return diceRoll;
    }
}
// Example output:
//    Shaking dice...
//    You rolled 8
</code></pre>

<h3>Fluxuri asincrone cu IAsyncEnumerable&lt;T&gt;</h3>
<p>O metodă asincronă poate returna un flux asincron, reprezentat de IAsyncEnumerable&lt;T&gt;. Un flux asincron oferă o modalitate de a enumera elementele citite dintr-un flux atunci când elementele sunt generate în bucăți cu apeluri asincrone repetate. Exemplul următor arată o metodă asincronă care generează un flux asincron:</p>

<pre><code class="lang-csharp">static async IAsyncEnumerable<string> ReadWordsFromStreamAsync()
{
    string data =
        "This is a line of text.
              Here is the second line of text.
              And there is one more for good measure.
              Wait, that was the penultimate line."

    using var readStream = new StringReader(data);

    string? line = await readStream.ReadLineAsync();
    while (line != null)
    {
        foreach (string word in line.Split(' ', StringSplitOptions.RemoveEmptyEntries))
        {
            yield return word;
        }

        line = await readStream.ReadLineAsync();
    }
}
</code>
</pre>
</div>

<div>
<h2>7.4 Anularea unei liste de sarcini</h2>
<p>Puteți anula o aplicație console asincronă dacă nu doriți să așteptați să se termine. Urmarind exemplul din acest topic, puteți adăuga o anulare la o aplicație care descarcă conținutul unei liste de site-uri web. Puteți anula multe sarcini prin asocierea instanței CancellationTokenSource cu fiecare sarcină. Dacă selectați tasta Enter, se anulează toate sarcinile care nu sunt încă finalizate.</p>

<h3>Acest tutorial acoperă:</h3>
<ul>
  <li>Crearea unei aplicații console .NET</li>
  <li>Scrierea unei aplicații asincrone care suportă anularea</li>
  <li>Demonstrarea semnalizării anularii.</li>
</ul>

<h3>In definitia clasei Program, adaugati:</h3>
<pre><code class="lang-csharp">static readonly CancellationTokenSource s_cts = new CancellationTokenSource();

static readonly HttpClient s_client = new HttpClient
{
    MaxResponseContentBufferSize = 1_000_000
};

static readonly IEnumerable<string> s_urlList = new string[]
{
    &quot;https://learn.microsoft.com&quot;,
    &quot;https://learn.microsoft.com/aspnet/core&quot;,
    &quot;https://learn.microsoft.com/azure&quot;,
    &quot;https://learn.microsoft.com/azure/devops&quot;,
    &quot;https://learn.microsoft.com/dotnet&quot;,
    &quot;https://learn.microsoft.com/dynamics365&quot;,
    &quot;https://learn.microsoft.com/education&quot;,
    &quot;https://learn.microsoft.com/enterprise-mobility-security&quot;,
    &quot;https://learn.microsoft.com/gaming&quot;,
    &quot;https://learn.microsoft.com/graph&quot;,
    &quot;https://learn.microsoft.com/microsoft-365&quot;,
    &quot;https://learn.microsoft.com/office&quot;,
    &quot;https://learn.microsoft.com/powershell&quot;,
    &quot;https://learn.microsoft.com/sql&quot;,
    &quot;https://learn.microsoft.com/surface&quot;,
    &quot;https://learn.microsoft.com/system-center&quot;,
    &quot;https://learn.microsoft.com/visualstudio&quot;,
    &quot;https://learn.microsoft.com/windows&quot;,
    &quot;https://learn.microsoft.com/xamarin&quot;
};
</code>
</pre>

<h3>Updatati entry point-ul aplicatiei: </h3>

<pre><code class="lang-csharp">static async Task Main()
{
    Console.WriteLine(&quot;Application started.&quot;);
    Console.WriteLine(&quot;Press the ENTER key to cancel...\n&quot;);

    Task cancelTask = Task.Run(() =>
    {
        while (Console.ReadKey().Key != ConsoleKey.Enter)
        {
            Console.WriteLine(&quot;Press the ENTER key to cancel...&quot;);
        }

        Console.WriteLine(&quot;\nENTER key pressed: cancelling downloads.\n&quot;);
        s_cts.Cancel();
    });

    Task sumPageSizesTask = SumPageSizesAsync();

    Task finishedTask = await Task.WhenAny(new[] { cancelTask, sumPageSizesTask });
    if (finishedTask == cancelTask)
    {
        // wait for the cancellation to take place:
        try
        {
            await sumPageSizesTask;
            Console.WriteLine(&quot;Download task completed before cancel request was processed.&quot;);
        }
        catch (TaskCanceledException)
        {
            Console.WriteLine(&quot;Download task has been cancelled.&quot;);
        }
    }

    Console.WriteLine(&quot;Application ending.&quot;);
}
</code></pre>

<h3>Creati metoda asincrona SumPageSizes</h3>
<pre><code class="lang-csharp">static async Task SumPageSizesAsync()
{
    var stopwatch = Stopwatch.StartNew();

    int total = 0;
    foreach (string url in s_urlList)
    {
        int contentLength = await ProcessUrlAsync(url, s_client, s_cts.Token);
        total += contentLength;
    }

    stopwatch.Stop();

    Console.WriteLine($&quot;\nTotal bytes returned:  {total:#,#}&quot;);
    Console.WriteLine($&quot;Elapsed time:          {stopwatch.Elapsed}\n&quot;);
}
</code>
</pre>

<h3>Creati metoda asincrona de procesare</h3>
<pre>
<code class="lang-csharp">static async Task<int> ProcessUrlAsync(string url, HttpClient client, CancellationToken token)
{
    HttpResponseMessage response = await client.GetAsync(url, token);
    byte[] content = await response.Content.ReadAsByteArrayAsync(token);
    Console.WriteLine($&quot;{url,-60} {content.Length,10:#,#}&quot;);

    return content.Length;
}
</code>
</pre>
</div>

<div>
<h2>7.5 Anularea unui task asincron dupa o perioada de timp</h2>
  <p>Puteți anula o operație asincronă după un anumit timp folosind metoda CancellationTokenSource.CancelAfter dacă nu doriți să așteptați finalizarea operației. Această metodă programează anularea oricăror sarcini asociate care nu sunt finalizate în perioada de timp desemnată de expresia CancelAfter.</p>
   <p>Acest exemplu adaugă codului dezvoltat în <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/cancel-an-async-task-or-a-list-of-tasks">Anulează o listă de sarcini (C#)</a> pentru a descărca o listă de site-uri web și pentru a afișa lungimea conținutului fiecăruia.</p>
   <p>Această prezentare acoperă:</p>
   <ul>
      <li>Actualizarea unei aplicații .NET console existente</li>
      <li>Programarea unei anulări</li>
   </ul>

   <h3>Updatati entry point-ul aplicatiei</h3>
   <pre>
   <code class="lang-csharp">static async Task Main()
{
    Console.WriteLine(&quot;Application started.&quot;);

    try
    {
        s_cts.CancelAfter(3500);

        await SumPageSizesAsync();
    }
    catch (OperationCanceledException)
    {
        Console.WriteLine(&quot;\nTasks cancelled: timed out.\n&quot;);
    }
    finally
    {
        s_cts.Dispose();
    }

    Console.WriteLine(&quot;Application ending.&quot;);
}
</code>
   </pre>

   <h3>Exemplu complet</h3>
   <pre>
   <code class="lang-csharp">using System.Diagnostics;

class Program
{
    static readonly CancellationTokenSource s_cts = new CancellationTokenSource();

    static readonly HttpClient s_client = new HttpClient
    {
        MaxResponseContentBufferSize = 1_000_000
    };

    static readonly IEnumerable<string> s_urlList = new string[]
    {
            &quot;https://learn.microsoft.com&quot;,
            &quot;https://learn.microsoft.com/aspnet/core&quot;,
            &quot;https://learn.microsoft.com/azure&quot;,
            &quot;https://learn.microsoft.com/azure/devops&quot;,
            &quot;https://learn.microsoft.com/dotnet&quot;,
            &quot;https://learn.microsoft.com/dynamics365&quot;,
            &quot;https://learn.microsoft.com/education&quot;,
            &quot;https://learn.microsoft.com/enterprise-mobility-security&quot;,
            &quot;https://learn.microsoft.com/gaming&quot;,
            &quot;https://learn.microsoft.com/graph&quot;,
            &quot;https://learn.microsoft.com/microsoft-365&quot;,
            &quot;https://learn.microsoft.com/office&quot;,
            &quot;https://learn.microsoft.com/powershell&quot;,
            &quot;https://learn.microsoft.com/sql&quot;,
            &quot;https://learn.microsoft.com/surface&quot;,
            &quot;https://learn.microsoft.com/system-center&quot;,
            &quot;https://learn.microsoft.com/visualstudio&quot;,
            &quot;https://learn.microsoft.com/windows&quot;,
            &quot;https://learn.microsoft.com/xamarin&quot;
    };

    static async Task Main()
    {
        Console.WriteLine(&quot;Application started.&quot;);

        try
        {
            s_cts.CancelAfter(3500);

            await SumPageSizesAsync();
        }
        catch (OperationCanceledException)
        {
            Console.WriteLine(&quot;\nTasks cancelled: timed out.\n&quot;);
        }
        finally
        {
            s_cts.Dispose();
        }

        Console.WriteLine(&quot;Application ending.&quot;);
    }

    static async Task SumPageSizesAsync()
    {
        var stopwatch = Stopwatch.StartNew();

        int total = 0;
        foreach (string url in s_urlList)
        {
            int contentLength = await ProcessUrlAsync(url, s_client, s_cts.Token);
            total += contentLength;
        }

        stopwatch.Stop();

        Console.WriteLine($&quot;\nTotal bytes returned:  {total:#,#}&quot;);
        Console.WriteLine($&quot;Elapsed time:          {stopwatch.Elapsed}\n&quot;);
    }

    static async Task<int> ProcessUrlAsync(string url, HttpClient client, CancellationToken token)
    {
        HttpResponseMessage response = await client.GetAsync(url, token);
        byte[] content = await response.Content.ReadAsByteArrayAsync(token);
        Console.WriteLine($&quot;{url,-60} {content.Length,10:#,#}&quot;);

        return content.Length;
    }
}
</code>
   </pre>


</div>
<h2>7.7 Procesarea sarcinilor asincrone pe măsură ce acestea sunt finalizate</h2>

<p>Prin utilizarea Task.WhenAny, puteți să începeți mai multe sarcini în același timp și să le procesați una câte una pe măsură ce sunt finalizate, în loc să le procesați în ordinea în care au fost începute.</p>

<p>Exemplul următor utilizează o interogare pentru a crea o colecție de sarcini. Fiecare sarcină descarcă conținutul unui site web specificat. În fiecare iterație a unei bucle while, o apelare așteptată la WhenAny returnează sarcina din colecția de sarcini care termină prima descărcarea. Acea sarcină este eliminată din colecție și procesată. Buclele se repetă până când colecția nu mai conține sarcini.</p>

<h3>Precondiții</h3>

<p>Puteți urma acest tutorial, utilizând una dintre următoarele opțiuni:</p>

<ul>
    <li>Visual Studio 2022 cu mediul de lucru desktop .NET instalat. SDK-ul .NET este instalat automat atunci când selectați această încărcare.</li>
    <li>SDK-ul .NET cu un editor de cod la alegere, cum ar fi Visual Studio Code.</li>
</ul>

<h3>Crearea unui exemplu de aplicație</h3>

<p>Creați o nouă aplicație de tip consolă .NET Core. Puteți să creați una folosind comanda dotnet new console sau din Visual Studio.</p>

<p>Deschideți fișierul Program.cs în editorul de cod și înlocuiți codul existent cu următorul cod:</p>

<pre><code>
    using System.Diagnostics;

    namespace ProcessTasksAsTheyFinish;

    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
</code></pre>

<h3>Adăugare câmpuri</h3>

<p>În definiția clasei Program, adăugați următoarele două câmpuri:</p>

<pre><code>
    static readonly HttpClient s_client = new HttpClient
    {
        MaxResponseContentBufferSize = 1_000_000
    };
    
    static readonly IEnumerable&lt;string&gt; s_urlList = new string[]
    {
        "https://learn.microsoft.com",
        "https://learn.microsoft.com/aspnet/core",
        "https://learn.microsoft.com/azure",
        "https://learn.microsoft.com/azure/devops",
        "https://learn.microsoft.com/dotnet",
        "https://learn.microsoft.com/dynamics365",
        "https://learn.microsoft.com/education",
        "https://learn.microsoft.com/enterprise-mobility-security",
        "https://learn.microsoft.com/gaming",
        "https://learn.microsoft.com/graph",
        "https://learn.microsoft.com/microsoft-365",
        "https://learn.microsoft.com/office",
        "https://learn.microsoft.com/powershell",
        "https://learn.microsoft.com/sql",
        "https://learn.microsoft.com/surface",
        "https://learn.microsoft.com/system-center",
        "https://learn.microsoft.com/visualstudio",
        "https://learn.microsoft.com/windows",
        "https://learn.microsoft.com/xamarin"
    };
</code></pre>

<p>HttpClient oferă posibilitatea de a trimite cereri HTTP și de a primi răspunsuri HTTP. s_urlList păstrează toate URL-urile pe care aplicația planifică să le proceseze.</p>

<h3>Actualizarea punctului de intrare al aplicației</h3>

<p>Punctul principal de intrare în aplicația de tip consolă este metoda Main. Înlocuiți metoda existentă cu următoarea metodă:</p>

<pre><code>
    static Task Main() => SumPageSizesAsync();
</code></pre>

<p>Noua metodă Main actualizată este acum considerată o metodă Async, care permite un punct de intrare asincron în executabil. Acesta este exprimat ca o apelare a metodei SumPageSizesAsync.</p>

<h3>Crearea metodei asincrone de calcul al dimensiunilor paginilor</h3>

<p>Sub metoda Main, adăugați metoda SumPageSizesAsync:</p>

<pre><code>
    static async Task SumPageSizesAsync()
    {
        var stopwatch = Stopwatch.StartNew();

        IEnumerable&lt;Task&lt;int&gt;&gt; downloadTasksQuery =
            from url in s_urlList
            select ProcessUrlAsync(url, s_client);

        List&lt;Task&lt;int&gt;&gt; downloadTasks = downloadTasksQuery.ToList();

        int total = 0;
        while (downloadTasks.Any())
        {
            Task&lt;int&gt; finishedTask = await Task.WhenAny(downloadTasks);
            downloadTasks.Remove(finishedTask);
            total += await finishedTask;
        }

        stopwatch.Stop();

        Console.WriteLine($"\nTotal bytes returned:  {total:#,#}");
        Console.WriteLine($"Elapsed time:          {stopwatch.Elapsed}\n");
    }
</code></pre>

<p>Bucla while înlătură una dintre task-uri în fiecare iterație. După ce fiecare task s-a terminat, bucla se încheie. Metoda începe prin instanțierea și pornirea unui cronometru Stopwatch. Apoi include o interogare care, atunci când este executată, creează o colecție de task-uri. Fiecare apel al metodei ProcessUrlAsync din codul următor returnează un Task&lt;TResult&gt;, unde TResult este un număr întreg:</p>

<pre><code>
    IEnumerable&lt;Task&lt;int&gt;&gt; downloadTasksQuery =
        from url in s_urlList
        select ProcessUrlAsync(url, s_client);
</code></pre>

<p>Datorită execuției amânate cu LINQ, apelați Enumerable.ToList pentru a începe fiecare task</p>

<pre><code>
    List&lt;Task&lt;int&gt;&gt; downloadTasks = downloadTasksQuery.ToList();
</code></pre>
.
<p>Bucla while efectuează următorii pași pentru fiecare task din colecție:</p>

<p>1. Așteaptă un apel la WhenAny pentru a identifica primul task din colecție care a terminat descărcarea.</p>

<pre><code>
    Task&lt;int&gt; finishedTask = await Task.WhenAny(downloadTasks);
</code></pre>

<p>2. Înlătură acel task din colecție.</p>

<pre><code>
    downloadTasks.Remove(finishedTask);
</code></pre>

<p>3. Așteaptă finishedTask, care este returnat de un apel la ProcessUrlAsync. Variabila finishedTask este un Task&lt;TResult&gt; unde TResult este un număr întreg. Task-ul este deja complet, dar se așteaptă pentru a obține lungimea site-ului descărcat, așa cum arată exemplul următor. Dacă task-ul a întâmpinat o problemă, await va arunca prima sub-excepție stocată în AggregateException, spre deosebire de citirea proprietății Task&lt;TResult&gt;.Result, care ar arunca AggregateException.</p>

<pre><code>
    total += await finishedTask;
</code></pre>

<h3>Adăugarea metodei de procesare</h3>

<p>Adăugați următoarea metodă ProcessUrlAsync sub metoda SumPageSizesAsync:</p>

<pre><code>
    static async Task&lt;int&gt; ProcessUrlAsync(string url, HttpClient client)
        {
            byte[] content = await client.GetByteArrayAsync(url);
            Console.WriteLine($"{url,-60} {content.Length,10:#,#}");
        
            return content.Length;
        }
</code></pre>

<p>Pentru orice URL dat, metoda va utiliza instanța clientului furnizată pentru a obține răspunsul ca un byte[]. Lungimea este returnată după ce URL-ul și lungimea sunt scrise în consolă.</p>

<p>Rulați programul de mai multe ori pentru a verifica că lungimile descărcate nu apar întotdeauna în aceeași ordine.</p>

<p>Atenție! Puteți utiliza WhenAny într-un ciclu, așa cum este descris în exemplul dat, pentru a rezolva probleme care implică un număr mic de sarcini. Cu toate acestea, alte abordări sunt mai eficiente dacă aveți un număr mare de sarcini de procesat. Pentru mai multe informații și exemple, consultați "Procesarea sarcinilor pe măsură ce acestea sunt finalizate".</p>

<h3>Exemplu complet</h3>

<p>Următorul cod conține textul complet al fișierului Program.cs pentru exemplul de mai sus.</p>

<pre><code>
    using System.Diagnostics;

    HttpClient s_client = new()
    {
        MaxResponseContentBufferSize = 1_000_000
    };
    
    IEnumerable&lt;string&gt; s_urlList = new string[]
    {
        "https://docs.microsoft.com",
        "https://docs.microsoft.com/aspnet/core",
        "https://docs.microsoft.com/azure",
        "https://docs.microsoft.com/azure/devops",
        "https://docs.microsoft.com/dotnet",
        "https://docs.microsoft.com/dynamics365",
        "https://docs.microsoft.com/education",
        "https://docs.microsoft.com/enterprise-mobility-security",
        "https://docs.microsoft.com/gaming",
        "https://docs.microsoft.com/graph",
        "https://docs.microsoft.com/microsoft-365",
        "https://docs.microsoft.com/office",
        "https://docs.microsoft.com/powershell",
        "https://docs.microsoft.com/sql",
        "https://docs.microsoft.com/surface",
        "https://docs.microsoft.com/system-center",
        "https://docs.microsoft.com/visualstudio",
        "https://docs.microsoft.com/windows",
        "https://docs.microsoft.com/xamarin"
    };
    
    await SumPageSizesAsync();
    
    async Task SumPageSizesAsync()
    {
        var stopwatch = Stopwatch.StartNew();
    
        IEnumerable&lt;Task&lt;int&gt;&gt; downloadTasksQuery =
            from url in s_urlList
            select ProcessUrlAsync(url, s_client);
    
        List&lt;Task&lt;int&gt;&gt; downloadTasks = downloadTasksQuery.ToList();
    
        int total = 0;
        while (downloadTasks.Any())
        {
            Task&lt;int&gt; finishedTask = await Task.WhenAny(downloadTasks);
            downloadTasks.Remove(finishedTask);
            total += await finishedTask;
        }
    
        stopwatch.Stop();
    
        Console.WriteLine($"\nTotal bytes returned:    {total:#,#}");
        Console.WriteLine($"Elapsed time:              {stopwatch.Elapsed}\n");
    }
    
    static async Task&lt;int&gt; ProcessUrlAsync(string url, HttpClient client)
    {
        byte[] content = await client.GetByteArrayAsync(url);
        Console.WriteLine($"{url,-60} {content.Length,10:#,#}");
    
        return content.Length;
    }
    
    // Example output:
    // https://docs.microsoft.com                                      132,517
    // https://docs.microsoft.com/powershell                            57,375
    // https://docs.microsoft.com/gaming                                33,549
    // https://docs.microsoft.com/aspnet/core                           88,714
    // https://docs.microsoft.com/surface                               39,840
    // https://docs.microsoft.com/enterprise-mobility-security          30,903
    // https://docs.microsoft.com/microsoft-365                         67,867
    // https://docs.microsoft.com/windows                               26,816
    // https://docs.microsoft.com/xamarin                               57,958
    // https://docs.microsoft.com/dotnet                                78,706
    // https://docs.microsoft.com/graph                                 48,277
    // https://docs.microsoft.com/dynamics365                           49,042
    // https://docs.microsoft.com/office                                67,867
    // https://docs.microsoft.com/system-center                         42,887
    // https://docs.microsoft.com/education                             38,636
    // https://docs.microsoft.com/azure                                421,663
    // https://docs.microsoft.com/visualstudio                          30,925
    // https://docs.microsoft.com/sql                                   54,608
    // https://docs.microsoft.com/azure/devops                          86,034
    
    // Total bytes returned:    1,454,184
    // Elapsed time:            00:00:01.1290403
</code></pre>

<br>

<h2>7.8 Accesul asincron la fișiere</h2>

<p>Puteți utiliza funcția asincronă pentru a accesa fișiere. Prin utilizarea acestei funcții, puteți apela metode asincrone fără a utiliza funcții de apel invers sau împărțirea codului în mai multe metode sau expresii lambda. Pentru a face codul sincron să devină asincron, trebuie doar să apelați o metodă asincronă în loc de una sincronă și să adăugați câteva cuvinte cheie în cod.</p>

<p>Puteți lua în considerare următoarele motive pentru adăugarea asincronismului în apelurile de acces la fișiere:</p>

<ul>
    <li>Asincronismul face aplicațiile UI mai receptive deoarece firul UI care lansează operația poate efectua alte lucrări. Dacă firul UI trebuie să execute cod care durează mult timp (de exemplu, mai mult de 50 de milisecunde), interfața utilizator poate îngheța până când I/O este complet și firul UI poate procesa din nou introducerea tastaturii și a mouse-ului și alte evenimente.</li>
    <li>Asincronismul îmbunătățește scalabilitatea ASP.NET și a altor aplicații bazate pe server prin reducerea necesității de a utiliza fire de execuție. Dacă aplicația utilizează un fir dedicat pentru fiecare răspuns și sunt gestionate simultan o mie de cereri, sunt necesare o mie de fire de execuție. Operațiile asincrone adesea nu trebuie să utilizeze un fir de execuție în timpul așteptării. Acestea utilizează firul existent de completare I/O doar pentru o perioadă scurtă la sfârșit.</li>
    <li>Latența unei operațiuni de acces la fișiere poate fi foarte mică în condițiile actuale, dar poate crește foarte mult în viitor. De exemplu, un fișier poate fi mutat pe un server care se află la celălalt capăt al lumii.</li>
    <li>Suprapunerea adăugată prin utilizarea funcției Async este mică.</li>
    <li>Sarcinile asincrone pot fi ușor executate în paralel.</li>
</ul>

<h3>Folosirea claselor adecvate</h3>

<p>Exemplele simple din acest subiect demonstrează utilizarea funcțiilor File.WriteAllTextAsync și File.ReadAllTextAsync. Pentru a avea un control mai precis asupra operațiilor de I/O ale fișierelor, utilizați clasa FileStream, care are o opțiune ce permite ca I/O-ul asincron să se producă la nivelul sistemului de operare. Prin utilizarea acestei opțiuni, puteți evita blocarea unui fir de execuție din pool-ul de fire în multe cazuri. Pentru a activa această opțiune, specificați argumentul useAsync=true sau options=FileOptions.Asynchronous în apelul constructorului.</p>

<p>Nu puteți utiliza această opțiune cu StreamReader și StreamWriter dacă le deschideți direct prin specificarea căii fișierului. Cu toate acestea, puteți utiliza această opțiune dacă le furnizați un Stream pe care clasa FileStream l-a deschis. Apelurile asincrone sunt mai rapide în aplicațiile UI, chiar dacă un fir din pool-ul de fire este blocat, deoarece firul UI nu este blocat în timpul așteptării.</p>

<h3>Scrierea textului</h3>

<p>Exemplele următoare scriu text într-un fișier. La fiecare declanșare a unei instrucțiuni await, metoda iese imediat. După finalizarea operațiilor de I/O a fișierului, metoda revine la instrucțiunea care urmează după instrucțiunea await. Modificatorul async este inclus în definiția metodelor care utilizează instrucțiunea await.</p>

<h3>Exemplu simplu</h3>

<pre><code>
    public async Task SimpleWriteAsync()
    {
        string filePath = "simple.txt";
        string text = $"Hello World";
    
        await File.WriteAllTextAsync(filePath, text);
    }
</code></pre>

<h3>Exemplu de control finit</h3>

<pre><code>
    public async Task ProcessWriteAsync()
    {
        string filePath = "temp.txt";
        string text = $"Hello World{Environment.NewLine}";
    
        await WriteTextAsync(filePath, text);
    }
    
    async Task WriteTextAsync(string filePath, string text)
    {
        byte[] encodedText = Encoding.Unicode.GetBytes(text);
    
        using var sourceStream =
            new FileStream(
                filePath,
                FileMode.Create, FileAccess.Write, FileShare.None,
                bufferSize: 4096, useAsync: true);
    
        await sourceStream.WriteAsync(encodedText, 0, encodedText.Length);
    }
</code></pre>

<p>Exemplul original conține instrucțiunea await sourceStream.WriteAsync(encodedText, 0, encodedText.Length);, care este o contracție a următoarelor două instrucțiuni:</p>

<pre><code>
    Task theTask = sourceStream.WriteAsync(encodedText, 0, encodedText.Length);
    await theTask;
</code></pre>

<p>Prima instrucțiune returnează o sarcină și determină începerea procesării fișierului. A doua instrucțiune, împreună cu await, face ca metoda să iasă imediat și să returneze o altă sarcină. Când procesarea fișierului se va finaliza mai târziu, execuția va reveni la instrucțiunea care urmează după await.</p>

<h3>Citirea textului</h3>

<p>Următorul exemplu citește textul dintr-un fișier</p>

<h3>Exemplu simplu</h3>

<pre><code>
    public async Task SimpleReadAsync()
    {
        string filePath = "simple.txt";
        string text = await File.ReadAllTextAsync(filePath);
    
        Console.WriteLine(text);
    }
</code></pre>

<h3>Exemplu de control finit</h3>

<p>Textul este memorat și, în acest caz, plasat într-un StringBuilder. Spre deosebire de exemplul anterior, evaluarea await produce o valoare. Metoda ReadAsync returnează un Task&lt;Int32&gt;, deci evaluarea await produce o valoare Int32 numRead după finalizarea operației. Pentru mai multe informații, consultați Tipuri de returnare asincronă (C#).</p>

<pre><code>
    public async Task ProcessReadAsync()
    {
        try
        {
            string filePath = "temp.txt";
            if (File.Exists(filePath) != false)
            {
                string text = await ReadTextAsync(filePath);
                Console.WriteLine(text);
            }
            else
            {
                Console.WriteLine($"file not found: {filePath}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
        }
    }
    
    async Task&lt;string&gt; ReadTextAsync(string filePath)
    {
        using var sourceStream =
            new FileStream(
                filePath,
                FileMode.Open, FileAccess.Read, FileShare.Read,
                bufferSize: 4096, useAsync: true);
    
        var sb = new StringBuilder();
    
        byte[] buffer = new byte[0x1000];
        int numRead;
        while ((numRead = await sourceStream.ReadAsync(buffer, 0, buffer.Length)) != 0)
        {
            string text = Encoding.Unicode.GetString(buffer, 0, numRead);
            sb.Append(text);
        }
    
        return sb.ToString();
    }
</code></pre>

<h3> I/O asincron paralel</h3>

<p>Următoarele exemple demonstrează procesarea paralelă prin scrierea a 10 fișiere text.</p>

<h3>Exemplu simplu</h3>

<p>Următoarele exemple demonstrează procesarea paralelă prin scrierea a 10 fișiere text.</p>

<pre><code>
    public async Task SimpleParallelWriteAsync()
    {
        string folder = Directory.CreateDirectory("tempfolder").Name;
        IList&lt;Task&gt; writeTaskList = new List&lt;Taskglt;();
    
        for (int index = 11; index <= 20; ++ index)
        {
            string fileName = $"file-{index:00}.txt";
            string filePath = $"{folder}/{fileName}";
            string text = $"In file {index}{Environment.NewLine}";
    
            writeTaskList.Add(File.WriteAllTextAsync(filePath, text));
        }
    
        await Task.WhenAll(writeTaskList);
    }
</code></pre>

<h3>Exemplu de control finit</h3>

<p>Pentru fiecare fișier, metoda WriteAsync returnează o sarcină care este apoi adăugată la o listă de sarcini. Declarația await Task.WhenAll(tasks); iese din metodă și continuă în interiorul metodei când procesarea fișierelor este completă pentru toate sarcinile.</p>

<p>Exemplul închide toate instanțele FileStream într-un bloc finally după ce sarcinile sunt completate. Dacă fiecare FileStream ar fi fost creat într-o instrucțiune using, FileStream-ul ar putea fi eliminat înainte ca sarcina să fie completă.</p>

<p>Orice creștere a performanței provine aproape în întregime din procesarea paralelă și nu din procesarea asincronă. Avantajele asincronismului sunt că nu blochează mai multe fire de execuție și că nu blochează firul interfeței de utilizator.</p>

<pre><code>
    public async Task ProcessMultipleWritesAsync()
    {
        IList<FileStream> sourceStreams = new List<FileStream>();
    
        try
        {
            string folder = Directory.CreateDirectory("tempfolder").Name;
            IList&lt;Task&gt; writeTaskList = new List&lt;Task&gt;();
    
            for (int index = 1; index <= 10; ++ index)
            {
                string fileName = $"file-{index:00}.txt";
                string filePath = $"{folder}/{fileName}";
    
                string text = $"In file {index}{Environment.NewLine}";
                byte[] encodedText = Encoding.Unicode.GetBytes(text);
    
                var sourceStream =
                    new FileStream(
                        filePath,
                        FileMode.Create, FileAccess.Write, FileShare.None,
                        bufferSize: 4096, useAsync: true);
    
                Task writeTask = sourceStream.WriteAsync(encodedText, 0, encodedText.Length);
                sourceStreams.Add(sourceStream);
    
                writeTaskList.Add(writeTask);
            }
    
            await Task.WhenAll(writeTaskList);
        }
        finally
        {
            foreach (FileStream sourceStream in sourceStreams)
            {
                sourceStream.Close();
            }
        }
    }
</code></pre>

<p>Atunci când utilizați metodele WriteAsync și ReadAsync, puteți specifica un CancellationToken, pe care îl puteți utiliza pentru a anula operația în mijlocul fluxului. Pentru mai multe informații, consultați "Anularea în firele de execuție gestionate".</p>
