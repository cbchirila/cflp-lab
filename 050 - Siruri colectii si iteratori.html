<!DOCTYPE html>

<body>
    <h1>5. Arrays(Vectori)</h1>
    <p>5.1 Array-uri prezentare generala</p>
    <p>5.2 Array-uri unidimensionale</p>
    <p>5.3 Array-uri multidimensionale</p>
    <p>5.4 Array-uri fragmentate</p>
    <p>5.5 Folosirea instructiunii foreach in array-uri</p>
    <p>5.6 Transmiterea array-urilor ca parametri</p>
    <p>5.7 Array-uri tipizate implicit</p>
    <p>5.8 Colectii</p>
    <p>5.9 Iteratori</p>
    
    <h1>5.1 Array-uri prezentare generala</h1>
    <p>Poți stoca mai multe variabile de același tip într-o structură de date de tip tablou. Declari un tablou prin
        specificarea tipului elementelor sale. Dacă dorești ca tabloul să stocheze elemente de orice tip, poți specifica
        'object' ca tip al său. În sistemul unificat de tipuri din C#, toate tipurile, atât cele predefinite cât și cele
        definite de utilizator, tipurile de referință și cele de valoare, moștenesc direct sau indirect din 'Object'.</p>

    <p>5.1.1: Declararea unui tablou in C#:</p>
    <pre>
            <code>
                type[] arrayName;
            </code>
        </pre>
    
    <h2>Exemplu:</h2>
    <p>Urmatorul exemplu creaza un tablou unidimensional,multidimensional si fragmentat:</p>
    <pre>
            <code>
                class TestArraysClass
                {
                static void Main()
                {
                // Declare a single-dimensional array of 5 integers.
                int[] array1 = new int[5];
                
                // Declare and set array element values.
                int[] array2 = new int[] { 1, 3, 5, 7, 9 };
                
                // Alternative syntax.
                int[] array3 = { 1, 2, 3, 4, 5, 6 };
                
                // Declare a two dimensional array.
                int[,] multiDimensionalArray1 = new int[2, 3];
                
                // Declare and set array element values.
                int[,] multiDimensionalArray2 = { { 1, 2, 3 }, { 4, 5, 6 } };
                
                // Declare a jagged array.
                int[][] jaggedArray = new int[6][];
                
                // Set the values of the first array in the jagged array structure.
                jaggedArray[0] = new int[4] { 1, 2, 3, 4 };
                }
                }
            </code>
        </pre>
    <p>5.1.2: Un array are urmatoarele proprietati:</p>
    <ul>
        <li>Un tablou poate fi unidimensional, multidimensional sau fragmentat.</li>
        <li>Numărul de dimensiuni și lungimea fiecărei dimensiuni sunt stabilite atunci când instanța tabloului este creată.
            Aceste
            valori nu pot fi schimbate pe parcursul duratei de viață a instanței.</li>
        <li>Valorile implicite ale elementelor unui tablou numeric sunt setate la zero, iar elementele de referință sunt
            setate la
            valoarea null.</li>
        <li>Un tablou fragmentat este un tablou de tablouri, prin urmare, elementele sale sunt de tip referință și sunt
            inițializate
            la valoarea null.</li>
        <li>Tablourile sunt indexate de la zero: un tablou cu n elemente este indexat de la 0 la n-1.</li>
        <li>Elementele tabloului pot fi de orice tip, inclusiv de tip tablou.</li>
        <li>Tipurile de tablouri sunt tipuri de referință derivate din tipul de bază abstract Array. Toate tablourile
            implementează
            IList și IEnumerable. Puteți utiliza instrucțiunea foreach pentru a itera prin intermediul unui tablou.
            Tablourile
            unidimensionale implementează, de asemenea, IList<T> și IEnumerable<T>.</li>
    </ul>
    <h2>5.1.3:Comportamentul valorii implicite:</h2>
    <ul>
        <li>Pentru tipurile de valoare, elementele tabloului sunt inițializate cu valoarea implicită, care este un model de
            biți
            format din 0-uri; astfel, elementele vor avea valoarea 0.</li>
        <li>Toate tipurile de referință (inclusiv cele care nu pot fi nule), au valoarea null.</li>
        <li>Pentru tipurile de valoare care pot fi nule, proprietatea HasValue este setată la false și elementele sunt
            setate la
            valoarea null.</li>
    </ul>
    <h2>5.1.4: Tablouri ca obiecte</h2>
    <p>În C#, tablourile sunt, de fapt, obiecte și nu doar regiuni de memorie adiacente adresabile, așa cum este cazul în C
        și
        C++. Array este tipul de bază abstract al tuturor tipurilor de tablouri. Puteți utiliza proprietățile și alte
        elemente
        de clasă pe care le are Array. Un exemplu în acest sens este utilizarea proprietății Length pentru a obține lungimea
        unui tablou. Următorul cod atribuie lungimea tabloului "numbers", care este 5, unei variabile numite
        "lengthOfNumbers":</p>
    <pre>
            <code>
                int[] numbers = { 1, 2, 3, 4, 5 };
                int lengthOfNumbers = numbers.Length;
            </code>
        </pre>
    <p>Clasa Array oferă multe alte metode și proprietăți utile pentru sortarea, căutarea și copierea tablourilor. Următorul
        exemplu utilizează proprietatea Rank pentru a afișa numărul de dimensiuni ale unui tablou.</p>
    <pre>
            <code>
                class TestArraysClass
                {
                static void Main()
                {
                // Declare and initialize an array.
                int[,] theArray = new int[5, 10];
                System.Console.WriteLine("The array has {0} dimensions.", theArray.Rank);
                }
                }
                // Output: The array has 2 dimensions.
            </code>
        </pre>
    
    
    <h1>5.2 Tablouri unidimensionale</h1>
    <p>Pentru a crea un tablou unidimensional, utilizați operatorul new specificând tipul elementului tabloului și numărul
        de
        elemente. Următorul exemplu declară un tablou de cinci numere întregi:</p>
    <pre>
            <code>
                int[] array = new int[5];
            </code>
        </pre>
    <p>Acest tablou conține elementele de la array[0] la array[4]. Elementele tabloului sunt inițializate cu valoarea
        implicită
        a tipului elementului, adică 0 pentru numere întregi.
    
        Tablourile pot stoca orice tip de element specificat, așa cum se arată în exemplul următor, care declară un tablou
        de
        șiruri de caractere:</p>
    <pre>
            <code>
                string[] stringArray = new string[6];
            </code>
        </pre>
    <h2>5.2.1: Inițializarea unui tablou</h2>
    <p>Puteți inițializa elementele unui tablou atunci când îl declarați. Specificatorul de lungime nu este necesar deoarece
        acesta este dedus din numărul de elemente din lista de inițializare. De exemplu:</p>
    <pre>
            <code>
                int[] array1 = new int[] { 1, 3, 5, 7, 9 };
            </code>
        </pre>
    <p>Codul următor arată declarația unui tablou de șiruri de caractere în care fiecare element al tabloului este
        inițializat
        cu numele unei zile:</p>
    <pre>
            <code>
                string[] weekDays = new string[] { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
            </code>
        </pre>
    <p>Puteți evita expresia new și tipul de tablou atunci când inițializați un tablou la declarare, cum se arată în codul
        următor. Acest lucru se numește tablou cu tip implicit:</p>
    <pre>
            <code>
                int[] array2 = { 1, 3, 5, 7, 9 };
                string[] weekDays2 = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
            </code>
        </pre>
    <p>Puteți declara o variabilă de tip tablou fără a o crea, dar trebuie să folosiți operatorul new atunci când atribuiți
        un
        nou tablou acestei variabile. De exemplu:</p>
    <pre>
            <code>
                int[] array3;
                array3 = new int[] { 1, 3, 5, 7, 9 }; // OK
                //array3 = {1, 3, 5, 7, 9}; // Error
            </code>
        </pre>
    <h2>5.2.2: Tablourile de tip valoare și de tip referință</h2>
    <p>Luați în considerare următoarea declarație de tablou:</p>
    <pre>
            <code>
                SomeType[] array4 = new SomeType[10];
            </code>
        </pre>
    <p>Rezultatul acestei declarații depinde de faptul dacă SomeType este un tip de valoare sau un tip de referință. Dacă
        este
        un tip de valoare, declarația creează un tablou de 10 elemente, fiecare cu tipul SomeType. Dacă SomeType este un tip
        de
        referință, declarația creează un tablou de 10 elemente, fiecare inițializat la o referință nulă. În ambele cazuri,
        elementele sunt inițializate cu valoarea implicită pentru tipul elementului. Pentru mai multe informații despre
        tipurile
        de valoare și tipurile de referință, consultați Tipurile de valoare și Tipurile de referință.</p>
    <h2>5.2.3: Obținerea datelor dintr-un array</h2>
    <p>Puteți recupera datele unui tablou folosind un index. De exemplu:</p>
    <pre>
            <code>
                string[] weekDays2 = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
                
                Console.WriteLine(weekDays2[0]);
                Console.WriteLine(weekDays2[1]);
                Console.WriteLine(weekDays2[2]);
                Console.WriteLine(weekDays2[3]);
                Console.WriteLine(weekDays2[4]);
                Console.WriteLine(weekDays2[5]);
                Console.WriteLine(weekDays2[6]);
                
                /*Output:
                Sun
                Mon
                Tue
                Wed
                Thu
                Fri
                Sat
                */
            </code>
        </pre>
    
    
    
    <h1>5.3 Tablouri multidimensionale</h1>
    <p>Array-urile pot avea mai mult de o dimensiune. De exemplu, următoarea declarație creează un array bidimensional cu
        patru
        rânduri și două coloane.</p>
    <pre>
            <code>
                int[,] array = new int[4, 2];
            </code>
        </pre>
    <p>Următoarea declarație creează un array de trei dimensiuni, 4, 2 și 3.</p>
    <pre>
            <code>
                int[,,] array1 = new int[4, 2, 3];
            </code>
        </pre>
    <h2>5.3.1: Inițializarea unui tablou</h2>
    <p>Puteți inițializa matricea la declarare, așa cum este arătat în următorul exemplu.</p>
    <pre>
            <code>
                // Two-dimensional array.
                    int[,] array2D = new int[,] { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 } };
                // The same array with dimensions specified.
                    int[,] array2Da = new int[4, 2] { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 } };
                // A similar array with string elements.
                    string[,] array2Db = new string[3, 2] { { "one", "two" }, { "three", "four" },
                { "five", "six" } };
                
                // Three-dimensional array.
                    int[,,] array3D = new int[,,] { { { 1, 2, 3 }, { 4, 5, 6 } },
                { { 7, 8, 9 }, { 10, 11, 12 } } };
                // The same array with dimensions specified.
                    int[,,] array3Da = new int[2, 2, 3] { { { 1, 2, 3 }, { 4, 5, 6 } },
                { { 7, 8, 9 }, { 10, 11, 12 } } };
                
                // Accessing array elements.
                System.Console.WriteLine(array2D[0, 0]);
                System.Console.WriteLine(array2D[0, 1]);
                System.Console.WriteLine(array2D[1, 0]);
                System.Console.WriteLine(array2D[1, 1]);
                System.Console.WriteLine(array2D[3, 0]);
                System.Console.WriteLine(array2Db[1, 0]);
                System.Console.WriteLine(array3Da[1, 0, 1]);
                System.Console.WriteLine(array3D[1, 1, 2]);
                
                // Getting the total count of elements or the length of a given dimension.
                var allLength = array3D.Length;
                var total = 1;
                for (int i = 0; i < array3D.Rank; i++) { total *=array3D.GetLength(i); } System.Console.WriteLine("{0} equals {1}",
                    allLength, total); // Output: // 1 // 2 // 3 // 4 // 7 // three // 8 // 12 // 12 equals 12
            </code>
        </pre>
    <p>Puteți, de asemenea, să inițializați array-ul fără a specifica dimensiunea.</p>
    <pre>
            <code>
                int[,] array4 = { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 } };
            </code>
        </pre>
    <p>Dacă alegeți să declarați o variabilă array fără a o inițializa, trebuie să utilizați operatorul new pentru a atribui
        un
        array variabilei. Utilizarea operatorului new este prezentată în exemplul următor.</p>
    <pre>
            <code>
                int[,] array5;
                array5 = new int[,] { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 } }; // OK
                //array5 = {{1,2}, {3,4}, {5,6}, {7,8}}; // Error
            </code>
        </pre>
    <p>Exemplul următor atribuie o valoare unui anumit element dintr-un tablou.</p>
    <pre>
            <code>
                array5[2, 1] = 25;
            </code>
        </pre>
    <p>În mod similar, următorul exemplu obține valoarea unui element de tip array și o atribuie variabilei elementValue.
    </p>
    <pre>
            <code>
                int elementValue = array5[2, 1];
            </code>
        </pre>
    <p>Exemplul de cod următor inițializează elementele matricei la valorile implicite (cu excepția matricelor fragmentate).
    </p>
    <pre>
            <code>
                int[,] array6 = new int[10, 10];
            </code>
        </pre>
    
    
    
    <h1>5.4 Tablouri(Matrice) fragmentate</h1>
    <p>Un array fragmentat este un array al carui elemente sunt alte array-uri, cu posibile dimensiuni diferite. Un astfel
        de
        array este numit uneori "array de array-uri". Următoarele exemple arată cum se poate declara, inițializa și accesa
        astfel de array-uri.
    
        Mai jos avem o declarație a unui array uni-dimensional care are trei elemente, fiecare dintre ele fiind un array
        uni-dimensional de numere întregi:</p>
    <pre>
            <code>
                int[][] jaggedArray = new int[3][];
            </code>
        </pre>
    <p>Înainte de a putea utiliza jaggedArray, elementele sale trebuie să fie inițializate. Puteți inițializa elementele
        astfel:</p>
    <pre>
            <code>
                jaggedArray[0] = new int[5];
                jaggedArray[1] = new int[4];
                jaggedArray[2] = new int[2];
            </code>
        </pre>
    <p>Fiecare dintre elemente este un array unidimensional de întregi. Primul element este un array de 5 întregi, al doilea
        este un array de 4 întregi, iar al treilea este un array de 2 întregi.</p>
    
    <p>Este de asemenea posibil să utilizați inițializatoare pentru a umple elementele array-ului cu valori, caz în care nu
        aveți nevoie de dimensiunea array-ului. De exemplu:</p>
    <pre>
            <code>
                jaggedArray[0] = new int[] { 1, 3, 5, 7, 9 };
                jaggedArray[1] = new int[] { 0, 2, 4, 6 };
                jaggedArray[2] = new int[] { 11, 22 };
            </code>
        </pre>
    <p>Puteți, de asemenea, să inițializați matricea la declarare astfel:</p>
    <pre>
            <code>
                int[][] jaggedArray2 = new int[][]
                {
                new int[] { 1, 3, 5, 7, 9 },
                new int[] { 0, 2, 4, 6 },
                new int[] { 11, 22 }
                };
            </code>
        </pre>
    <p>Puteți folosi următoarea formă prescurtată. Observați că nu puteți omite operatorul new din inițializarea
        elementelor,
        deoarece nu există inițializare implicită pentru elemente:</p>
    <pre>
            <code>
                int[][] jaggedArray3 =
                {
                new int[] { 1, 3, 5, 7, 9 },
                new int[] { 0, 2, 4, 6 },
                new int[] { 11, 22 }
                };
            </code>
        </pre>
    <p>Un jagged array este un array de array-uri, prin urmare elementele sale sunt tipuri de referință și sunt inițializate
        la
        null.</p>
    <p>Puteți accesa elementele individuale ale array-ului folosind exemplele de mai jos:</p>
    <pre>
            <code>
                // Assign 77 to the second element ([1]) of the first array ([0]):
                jaggedArray3[0][1] = 77;
                
                // Assign 88 to the second element ([1]) of the third array ([2]):
                jaggedArray3[2][1] = 88;
            </code>
        </pre>
    <p>Este posibil să se amestece tablouri fragmentate și multidimensionale. Următorul exemplu arată o declarație și
        inițializare
        a unui tablou zimțat unidimensional care conține trei elemente de tablou bidimensionale cu dimensiuni diferite.
        Pentru
        mai multe informații, consultați Tablouri Multidimensionale.</p>
    <pre>
            <code>
                int[][,] jaggedArray4 = new int[3][,]
                {
                new int[,] { {1,3}, {5,7} },
                new int[,] { {0,2}, {4,6}, {8,10} },
                new int[,] { {11,22}, {99,88}, {0,9} }
                };
            </code>
        </pre>
    <p>Puteți accesa elementele individuale așa cum este arătat în acest exemplu, care afișează valoarea elementului [1,0]
        din
        primul array (valoarea 5):</p>
    <pre>
            <code>
                System.Console.Write("{0}", jaggedArray4[0][1, 0]);
            </code>
        </pre>
    <p>Metoda Length returnează numărul de vectori conținuți într-un jagged array. De exemplu, presupunând că ați declarat
        array-ul anterior, această linie:</p>
    <pre>
            <code>
                System.Console.WriteLine(jaggedArray4.Length);
            </code>
        </pre>
    
    
    <h1>5.5 Utilizarea instrucțiunii foreach cu array-uri</h1>
    <p>Instrucțiunea foreach oferă o modalitate simplă și curată de a itera prin elementele unui tablou.
    </p>
    <p>Pentru tablouri unidimensionale, instrucțiunea foreach procesează elementele în ordine crescătoare a indexului,
        începând
        cu indexul 0 și terminând cu indexul Length - 1:</p>
    <pre>
            <code>
                int[] numbers = { 4, 5, 6, 1, 2, 3, -2, -1, 0 };
                foreach (int i in numbers)
                {
                Syste`m.Console.Write("{0} ", i);
                }
                // Output: 4 5 6 1 2 3 -2 -1 0
            </code>
        </pre>
    <p>Pentru matricile multidimensionale, elementele sunt parcurse astfel încât indicii celei mai din dreapta dimensiuni
        sunt
        crescuți mai întâi, apoi următoarea dimensiune din stânga și tot așa până la stânga.</p>
    <pre>
            <code>
                int[,] numbers2D = new int[3, 2] { { 9, 99 }, { 3, 33 }, { 5, 55 } };
                // Or use the short form:
                // int[,] numbers2D = { { 9, 99 }, { 3, 33 }, { 5, 55 } };
                
                foreach (int i in numbers2D)
                {
                System.Console.Write("{0} ", i);
                }
                // Output: 9 99 3 33 5 55
            </code>
        </pre>
    <p>Cu toate acestea, în cazul matricelor multidimensionale, utilizarea unui for loop încorporat oferă mai mult control
        asupra ordinei în care să se proceseze elementele matricei.</p>




    
    <h1>5.6 Transmiterea tablourilor ca parametrii</h1>

    <p>Tablourile pot fi transmise ca argumente la parametrii metodei.
        Deoarece tablourile sunt tipuri de referință,
        metoda poate modifica valoarea elementelor.</p>

    <h2>5.6.1 Transmiterea tablourilor unidimensionale ca argumente</h2>
    <p>Puteți transmite un tablou unidimensional inițializat la o metodă.
        De exemplu, următoarea secvență transmite un tablou către o metodă de scriere.
    <pre>
    <code>
        int[] theArray = { 1, 3, 5, 7, 9 };
        PrintArray(theArray);
    </code>
    </pre>

    Următorul cod arată o implementare parțială a metodei de scriere.
    <pre>
    <code>
        void PrintArray(int[] arr)
        {
             // Method code.
        }
    </code>
    </pre>

    Puteți inițializa și transmite un nou tablou într-un singur pas,
    așa cum se arată în următorul exemplu.

    <pre><code>
        PrintArray(new int[] { 1, 3, 5, 7, 9 });
     </code></pre>
    </p>

    <h3>Exemplu</h3>
    <p>În exemplul următor, un tablou de șiruri de caractere este inițializat și
        transmis ca un
        argument la o metodă DisplayArray pentru șiruri de caractere.
        Metoda afișează elementele
        tabloului. În continuare, metoda ChangeArray inversează elementele tabloului,
        iar apoi metoda ChangeArrayElements modifică primele trei elemente ale tabloului.
        După returnarea fiecărei metode, metoda DisplayArray arată că transmiterea unui
        tablou
        ca valoare nu împiedică modificările elementelor din tablou.

    <pre><code>
    using System;

    class ArrayExample
    {
        static void DisplayArray(string[] arr) => Console.WriteLine(string.Join(" ", arr));

        // Change the array by reversing its elements.
        static void ChangeArray(string[] arr) => Array.Reverse(arr);

        static void ChangeArrayElements(string[] arr)
        {
            // Change the value of the first three array elements.
            arr[0] = "Mon";
            arr[1] = "Wed";
            arr[2] = "Fri";
        }

        static void Main()
        {
            // Declare and initialize an array.
            string[] weekDays = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
            // Display the array elements.
            DisplayArray(weekDays);
            Console.WriteLine();

            // Reverse the array.
            ChangeArray(weekDays);
            // Display the array again to verify that it stays reversed.
            Console.WriteLine("Array weekDays after the call to ChangeArray:");
            DisplayArray(weekDays);
            Console.WriteLine();

            // Assign new values to individual array elements.
            ChangeArrayElements(weekDays);
            // Display the array again to verify that it has changed.
            Console.WriteLine("Array weekDays after the call to ChangeArrayElements:");
            DisplayArray(weekDays);
        }
    }
    // The example displays the following output:
    //         Sun Mon Tue Wed Thu Fri Sat
    //
    //        Array weekDays after the call to ChangeArray:
    //        Sat Fri Thu Wed Tue Mon Sun
    //
    //        Array weekDays after the call to ChangeArrayElements:
    //        Mon Wed Fri Wed Tue Mon Sun
   </code> </pre>
    </p>
    <h2>5.6.2 Transmiterea tablourior multidimensionale ca argumente</h2>

    <p>Puteți transmite la o metodă un tablou multidimensional inițializat
        în același mod în care transmiteți un tablou unidimensional.

    <pre><code>
    int[,] theArray = { { 1, 2 }, { 2, 3 }, { 3, 4 } };
    Print2DArray(theArray);
       </code> </pre>
    Următorul cod arată o declarație parțială a unei metode de imprimare
    care acceptă un tablou bidimensional ca argument.
    <pre><code>
     void Print2DArray(int[,] arr)
     {
        // Method code.
     }
      </code></pre>

    Puteți inițializa și transmite un nou tablou într -un singur pas,
    așa cum se arată în următorul exemplu:
    <pre><code>
    Print2DArray(new int[,] { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 } });
       </code> </pre>
    </p>
    <h3>Exemplu</h3>
    <p>
        În următorul exemplu,
        un tablou bidimensional de numere întregi este inițializat
        și transmis ca parametru la metodei Print2DArray.
        Metoda afișează elementele tabloului.
    <pre><code>
    class ArrayClass2D
    {
        static void Print2DArray(int[,] arr)
        {
            // Display the array elements.
            for (int i = 0; i < arr.GetLength(0); i++)
            {
                for (int j = 0; j < arr.GetLength(1); j++)
                {
                    System.Console.WriteLine("Element({0},{1})={2}", i, j, arr[i, j]);
                }
            }
        }
        static void Main()
        {
            // Pass the array as an argument.
            Print2DArray(new int[,] { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 } });

            // Keep the console window open in debug mode.
            System.Console.WriteLine("Press any key to exit.");
            System.Console.ReadKey();
        }
    }
    /* Output:
        Element(0,0)=1
        Element(0,1)=2
        Element(1,0)=3
        Element(1,1)=4
        Element(2,0)=5
        Element(2,1)=6
        Element(3,0)=7
        Element(3,1)=8
    */
</code></pre>
    </p>


    <h1>5.7 Tablouri tipizate implicit</h1>
    <p>
        Puteți crea un tablou tipizate implicit în care tipul instanței de tablou
        este dedus din elementele specificate în inițializarea tabloului.
        Regulile pentru orice variabilă cu tip implicit se aplică și tablourilor
        tipizate implicit.
        <br><br>

        Tablourile tipizate implicit sunt de obicei utilizate în expresiile de
        interogare împreună cu tipuri anonime și inițializatoare de obiecte și colecții.
        <br><br>
        Următoarele exemple arată cum să creezi un tablou tipizat implicit:
    <pre><code>
    class ImplicitlyTypedArraySample
    {
        static void Main()
        {
            var a = new[] { 1, 10, 100, 1000 }; // int[]
            var b = new[] { "hello", null, "world" }; // string[]

            // single-dimension jagged array
            var c = new[]
            {
                new[]{1,2,3,4},
                new[]{5,6,7,8}
            };

            // jagged array of strings
            var d = new[]
            {
                new[]{"Luca", "Mads", "Luke", "Dinesh"},
                new[]{"Karen", "Suma", "Frances"}
            };
        }
    }
       </code> </pre>
    În exemplul anterior, observați că la tablouri tipizate implicit, nu sunt
    utilizate paranteze pătrate în partea stângă a declarației de inițializare.
    Rețineți, de asemenea, că tablourile zimțate sunt inițializate
    folosind new [] la fel ca tablourile unidimensionale.
    </p>

    <h2>5.7.1 Tablouri tipizate implicit în inițializatorii de obiecte.</h2>
    <p>
        Când creați un tip anonim care conține un tablou, tabloul trebuie să fie
        implicit tipizat în inițializatorul de obiect al tipului. În exemplul următor,
        contacts este un tablou tipizat implicit de tipuri anonime, fiecare dintre acestea
        conținând un tablou numit PhoneNumbers. Observați că cuvântul cheie "var" nu este
        folosit în interiorul inițializatorului de obiecte.

    <pre> <code>
    var contacts = new[]
    {
        new {
            Name = " Eugene Zabokritski",
            PhoneNumbers = new[] { "206-555-0108", "425-555-0001" }
        },
        new {
            Name = " Hanying Feng",
            PhoneNumbers = new[] { "650-555-0199" }
        }
    };
  </code>  </pre>
    </p>
    <h1>5.8 Colecții</h1>
    <p>
        Pentru multe aplicații, doriți să creați și să gestionați grupuri de obiecte legate între ele. Există două
        modalități de a grupa obiecte: crearea de tablouri de obiecte și crearea de colecții de obiecte.
        <br><br>
        Tablourile sunt cele mai utile pentru crearea și lucrul cu un număr fix de obiecte puternic tipizate.
        <br><br>
        Colecțiile oferă o modalitate mai flexibilă de a lucra cu grupuri de obiecte. Spre deosebire de tablouri, grupul
        de obiecte cu care lucrați poate crește și scadea dinamic pe măsură ce necesitățile aplicației se schimbă.
        Pentru unele colecții, puteți atribui o cheie oricărui obiect pe care îl puneți în colecție, astfel încât să
        puteți recupera rapid obiectul folosind cheia.
        <br><br>
        O colecție este o clasă, deci trebuie să declarați o instanță a clasei înainte de a putea adăuga elemente în
        acea colecție.
        <Br><br>
        Dacă colecția dvs. conține elemente doar dintr-un singur tip de date, puteți utiliza una dintre clasele din
        spațiul de nume System.Collections.Generic. O colecție generică impune siguranța tipului astfel încât să nu se
        poată adăuga niciun alt tip de date în ea. Când recuperați un element dintr-o colecție generică, nu trebuie să
        determinați tipul său de date sau să-l convertiți.
        <br><br>
        For the examples in this topic, include using directives for the System.Collections.Generic and System.Linq
        namespaces.
    </p>

    <h2>5.8.1 Utilizarea unei colecții simple</h2>
    <p>
        Exemplele din această secțiune folosesc clasa generică List&lt;T&gt;,
        care vă permite să lucrați cu o listă de obiecte tipizate puternic.
        <br><br>
        Următorul exemplu creează o listă de șiruri și apoi parcurge
        șirurile folosind o instrucțiune foreach.
    <pre> <code>
    // Create a list of strings.
    var salmons = new List&lt;string&gt;();
    salmons.Add("chinook");
    salmons.Add("coho");
    salmons.Add("pink");
    salmons.Add("sockeye");

    // Iterate through the list.
    foreach (var salmon in salmons)
    {
        Console.Write(salmon + " ");
    }
    // Output: chinook coho pink sockeye
</code>  </pre>

    Dacă conținutul unei colecții este cunoscut în avans, puteți utiliza un inițializator de colecție pentru a
    inițializa colecția.
    <br><br>
    Următorul exemplu este identic cu exemplul anterior, cu excepția faptului că un inițializator de colecție este
    utilizat pentru a adăuga elemente în colecție.
    <pre> <code>
    // Create a list of strings by using a
    // collection initializer.
    var salmons = new List&lt;string&gt; { "chinook", "coho", "pink", "sockeye" };

    // Iterate through the list.
    foreach (var salmon in salmons)
    {
        Console.Write(salmon + " ");
    }
    // Output: chinook coho pink sockeye
    </code></pre>
    Puteți utiliza o instrucțiune for în loc de o instrucțiune foreach pentru a parcurge o colecție. Acest lucru se
    realizează prin accesarea elementelor colecției prin poziția indexului. Indexul elementelor începe de la 0 și se
    termină la numărul de elemente minus 1.
    <br><br>
    Următorul exemplu parcurge elementele unei colecții folosind instrucțiunea for
    în loc de foreach.
    <pre> <code>
    // Create a list of strings by using a
    // collection initializer.
    var salmons = new List&lt;string&gt; { "chinook", "coho", "pink", "sockeye" };

    for (var index = 0; index &lt; salmons.Count; index++)
    {
        Console.Write(salmons[index] + " ");
    }
    // Output: chinook coho pink sockeye
   </code></pre>
    Următorul exemplu elimină un element din colecție prin specificarea obiectului de eliminat.
    <pre> <code>
    // Create a list of strings by using a
    // collection initializer.
    var salmons = new List&lt;string&gt; { "chinook", "coho", "pink", "sockeye" };

    // Remove an element from the list by specifying
    // the object.
    salmons.Remove("coho");

    // Iterate through the list.
    foreach (var salmon in salmons)
    {
        Console.Write(salmon + " ");
    }
    // Output: chinook pink sockeye
   </code></pre>

    Următorul exemplu elimină elemente dintr-o listă generică.
    În loc de o instrucțiune foreach, este utilizată o instrucțiune
    for care parcurge în ordine descrescătoare. Aceasta se datorează
    faptului că metoda RemoveAt determină elementele după un element
    eliminat să aibă o valoare mai mică a indexului.
    <pre> <code>
    var numbers = new List&lt;int&gt; { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

    // Remove odd numbers.
    for (var index = numbers.Count - 1; index >= 0; index--)
    {
        if (numbers[index] % 2 == 1)
        {
            // Remove the element by specifying
            // the zero-based index in the list.
            numbers.RemoveAt(index);
        }
    }
            
    // Iterate through the list.
    // A lambda expression is placed in the ForEach method
    // of the List(T) object.
    numbers.ForEach(
                number => Console.Write(number + " "));
    // Output: 0 2 4 6 8
   </code> </pre>
    Pentru tipul de elemente din List&lt;T&gt;,
    puteți defini propriul dvs. clasă. În exemplul următor,
    clasa Galaxy, care este utilizată de List&lt;T&gt;, este definită în cod.
    <pre> <code>
    private static void IterateThroughList()
    {
        var theGalaxies = new List&lt;Galaxy&gt;
            {
                new Galaxy() { Name="Tadpole", MegaLightYears=400},
                new Galaxy() { Name="Pinwheel", MegaLightYears=25},
                new Galaxy() { Name="Milky Way", MegaLightYears=0},
                new Galaxy() { Name="Andromeda", MegaLightYears=3}
            };

        foreach (Galaxy theGalaxy in theGalaxies)
        {
            Console.WriteLine(theGalaxy.Name + "  " + theGalaxy.MegaLightYears);
        }

        // Output:
        //  Tadpole  400
        //  Pinwheel  25
        //  Milky Way  0
        //  Andromeda  3
    }

    public class Galaxy
    {
        public string Name { get; set; }
        public int MegaLightYears { get; set; }
    }
     </code></pre>
    </p>

    <h2>5.8.2 Tipuri de colecții</h2>

    <p>
        Multe colecți comune sunt oferite de .NET. Fiecare tip de colecție este
        conceput pentru un scop specific.
        <br><br>
        În această secțiune sunt descrise unele dintre clasele de colecție comune:
    <ul>
        <li>Clasele System.Collections.Generic</li>
        <li>Clasele System.Collections.Concurrent</li>
        <li> Clasele System.Collections</li>
    </ul>

    <h3>5.8.2.1 Clasele System.Collections.Generic</h3>
    Puteți crea o colecție generică folosind una dintre clasele din spațiul de nume System.Collections.Generic. O
    colecție generică este utilă atunci când fiecare element din colecție are același tip de date. O colecție generică
    impune tipul de date prin permiterea adăugării doar a tipului de date dorit.
    <br><br>
    Următorul tabel listează unele dintre clasele frecvent utilizate din spațiul de
    nume System.Collections.Generic:

    <table>
        <tr>
            <th>Clasa</th>
            <th>Descrierea</th>

        </tr>
        <tr>
            <td>Dictionary &lt;TKey,TValue&gt;</td>
            <td>Reprezintă o colecție de perechi cheie/valoare organizate în funcție de cheie.</td>
        </tr>
        <tr>
            <td>ListList &lt;T&gt;</td>
            <td>Reprezintă o listă de obiecte la care se poate accesa prin index. Oferă metode pentru căutarea, sortarea
                și modificarea listelor.</td>
        </tr>
        <tr>
            <td>Queue &lt;T&gt;</td>
            <td>Reprezintă o colecție de obiecte de tipul "primul intrat, primul ieșit" (FIFO).</td>
        </tr>
        <tr>
            <td>SortedList &lt;TKey,TValue&gt;</td>
            <td>Reprezintă o colecție de perechi cheie/valoare care sunt sortate după cheie, bazat pe implementarea
                IComparer&lt;T&gt; asociată.</td>
        </tr>
        <tr>
            <td>Stack &lt;T&gt;</td>
            <td>Reprezintă o colecție de obiecte de tipul "ultimul intrat, primul ieșit" (LIFO).</td>
        </tr>
    </table>

    <h3>5.8.2.2 Clasele System.Collections.Concurrent</h3>

    În .NET Framework 4 și versiunile ulterioare, colecțiile din spațiul de nume System.Collections.Concurrent
    furnizează operații eficiente sigure pentru thread-uri pentru accesarea elementelor colecției din mai multe
    thread-uri.
    <br><br>
    Clasele din spațiul de nume System.Collections.Concurrent trebuie utilizate în locul
    tipurilor corespunzătoare din spațiul de nume System.Collections.Generic și
    System.Collections atunci când mai multe thread-uri accesează colecția
    în mod concomitent.
    <br><br>
    Unele clase incluse în spațiul de nume System.Collections.Concurrent sunt
    BlockingCollection&lt;T&gt;, ConcurrentDictionary&lt;TKey, TValue&gt;,
    ConcurrentQueue&lt;T&gt; și ConcurrentStack&lt;T&gt;.

    <h3>5.8.2.3 Clasele System.Collections</h3>
    Clasele din spațiul de nume System.Collections nu stochează elemente ca obiecte cu tip specific, ci ca obiecte de
    tipul Object.
    <br><br>
    În cazul în care este posibil, ar trebui să utilizați colecțiile generice din spațiul de nume
    System.Collections.Generic sau spațiul de nume System.Collections.Concurrent în locul tipurilor vechi din spațiul de
    nume System.Collections.
    <br><br>
    Mai jos este prezentată o listă cu unele dintre clasele utilizate frecvent în spațiul de nume System.Collections:

    <table>
        <tr>
            <th>Clasa</th>
            <th>Descrierea</th>

        </tr>
        <tr>
            <td>ArrayList</td>
            <td>Reprezintă un tablou de obiecte a cărui dimensiune este mărită dinamic,
                în funcție de nevoi.</td>
        </tr>
        <tr>
            <td>Hashtable</td>
            <td> Reprezintă o colecție de perechi cheie/valoare organizate
                în funcție de codul hash al cheii.</td>
        </tr>
        <tr>
            <td>Queue &lt;T&gt;</td>
            <td>Reprezintă o colecție de obiecte de tipul "primul intrat, primul ieșit" (FIFO).</td>
        </tr>
        <tr>
            <td>Stack &lt;T&gt;</td>
            <td>Reprezintă o colecție de obiecte de tipul "ultimul intrat, primul ieșit" (LIFO).</td>
        </tr>
    </table>Spațiul de nume System.Collections.Specialized oferă clase specializate
    și puternic tipizate de colecții, cum ar fi colecții doar de șiruri de caractere și dicționare hibride și cu liste
    înlănțuite.


    <h3>5.8.2.4 Implementarea unei colecții de perechi cheie/valoare</h3>
    Dicționarul generic Dictionary&lt;TKey, TValue&gt;
    permite accesul la elementele dintr-o colecție prin utilizarea
    cheii fiecărui element. Fiecare adăugare în dicționar constă dintr-o
    valoare și cheia sa asociată. Recuperarea unei valori prin utilizarea
    cheii sale este rapidă datorită faptului că clasa Dictionary este implementată
    ca o tabelă hash.
    <br><br>
    Următorul exemplu creează o colecție Dictionary și parcurge dicționarul utilizând o
    instrucțiune foreach

    <pre> <code>
    private static void IterateThruDictionary()
    {
        Dictionary&lt;string, Element&gt; elements = BuildDictionary();

        foreach (KeyValuePair&lt;string, Element&gt; kvp in elements)
        {
            Element theElement = kvp.Value;

            Console.WriteLine("key: " + kvp.Key);
            Console.WriteLine("values: " + theElement.Symbol + " " +
                theElement.Name + " " + theElement.AtomicNumber);
        }
    }

    private static Dictionary&lt;string, Element&gt; BuildDictionary()
    {
        var elements = new Dictionary&lt;string, Element&gt;();

        AddToDictionary(elements, "K", "Potassium", 19);
        AddToDictionary(elements, "Ca", "Calcium", 20);
        AddToDictionary(elements, "Sc", "Scandium", 21);
        AddToDictionary(elements, "Ti", "Titanium", 22);

        return elements;
    }

    private static void AddToDictionary(Dictionary&lt;string, Element&gt; elements,
        string symbol, string name, int atomicNumber)
    {
        Element theElement = new Element();

        theElement.Symbol = symbol;
        theElement.Name = name;
        theElement.AtomicNumber = atomicNumber;

        elements.Add(key: theElement.Symbol, value: theElement);
    }

    public class Element
    {
        public string Symbol { get; set; }
        public string Name { get; set; }
        public int AtomicNumber { get; set; }
    }
   </code> </pre>

    Pentru a utiliza în schimb un inițializator de colecție pentru a construi
    colecția Dictionary, puteți înlocui metodele BuildDictionary și AddToDictionary
    cu următoarea metodă.
    <pre> <code>
    private static Dictionary&lt;string, Element&gt; BuildDictionary2()
    {
        return new Dictionary&lt;string, Element&gt;
        {
            {"K",
                new Element() { Symbol="K", Name="Potassium", AtomicNumber=19}},
            {"Ca",
                new Element() { Symbol="Ca", Name="Calcium", AtomicNumber=20}},
            {"Sc",
                new Element() { Symbol="Sc", Name="Scandium", AtomicNumber=21}},
            {"Ti",
                new Element() { Symbol="Ti", Name="Titanium", AtomicNumber=22}}
        };
    }
   </code></pre>
    Următorul exemplu folosește metoda ContainsKey și proprietatea Item[] a
    Dicționarelor pentru a găsi rapid un element după cheie. Proprietatea
    Item vă permite să accesați un element din colecția elements utilizând
    elements[symbol] în C#.
    <pre> <code>
    private static void FindInDictionary(string symbol)
    {
        Dictionary&lt;string, Element&gt; elements = BuildDictionary();

        if (elements.ContainsKey(symbol) == false)
        {
            Console.WriteLine(symbol + " not found");
        }
        else
        {
            Element theElement = elements[symbol];
            Console.WriteLine("found: " + theElement.Name);
        }
    }
   </code> </pre>
    Următorul exemplu folosește în schimb metoda TryGetValue
    pentru a găsi rapid un element după cheie.

    <pre> <code>
    private static void FindInDictionary2(string symbol)
    {
        Dictionary&lt;string, Element&gt; elements = BuildDictionary();

        Element theElement = null;
        if (elements.TryGetValue(symbol, out theElement) == false)
            Console.WriteLine(symbol + " not found");
        else
            Console.WriteLine("found: " + theElement.Name);
    }
    </code> </pre>
    <h3>5.8.2.5 Accesarea unei colecții folosind LINQ </h3>

    LINQ (Interogare Integrată în Limbaj) poate fi utilizat pentru a accesa colecțiile.
    Interogările LINQ oferă capabilități de filtrare, sortare și grupare.
    <br><br>
    Următorul exemplu rulează o interogare LINQ asupra unei liste generice.
    Interogarea LINQ returnează o altă colecție care conține rezultatele.

    <pre> <code>
    private static void ShowLINQ()
    {
        List&lt;Element&gt; elements = BuildList();
    
        // LINQ Query.
        var subset = from theElement in elements
                     where theElement.AtomicNumber &lt; 22
                     orderby theElement.Name
                     select theElement;
    
        foreach (Element theElement in subset)
        {
            Console.WriteLine(theElement.Name + " " + theElement.AtomicNumber);
        }
    
        // Output:
        //  Calcium 20
        //  Potassium 19
        //  Scandium 21
    }
    
    private static List&lt;Element&gt; BuildList()
    {
        return new List&lt;Element&gt;
        {
            { new Element() { Symbol="K", Name="Potassium", AtomicNumber=19}},
            { new Element() { Symbol="Ca", Name="Calcium", AtomicNumber=20}},
            { new Element() { Symbol="Sc", Name="Scandium", AtomicNumber=21}},
            { new Element() { Symbol="Ti", Name="Titanium", AtomicNumber=22}}
        };
    }
    
    public class Element
    {
        public string Symbol { get; set; }
        public string Name { get; set; }
        public int AtomicNumber { get; set; }
    }
  </code></pre>

    <h3>5.2.8.6 Sortarea unei colecții</h3>

    Următorul exemplu ilustrează o procedură de sortare a unei colecții.
    Exemplul sortează instanțele clasei Car care sunt stocate într-o List&lt;T&gt;.
    Clasa Car implementează interfața IComparable&lt;T&gt;, care necesită implementarea
    metodei CompareTo.
    <br><br>
    Fiecare apel al metodei CompareTo face o singură comparație care este utilizată
    pentru sortare. Codul scris de utilizator în metoda CompareTo returnează o valoare
    pentru fiecare comparație între obiectul curent și un alt obiect. Valoarea
    returnată este mai mică decât zero dacă obiectul curent este mai mic decât
    celălalt obiect, mai mare decât zero dacă obiectul curent este mai mare decât
    celălalt obiect și zero dacă sunt egale. Aceasta vă permite să definiți în cod
    criteriile pentru mai mare decât, mai mic decât și egal.
    <br><br>
    În metoda ListCars, instrucțiunea cars.Sort() sortează lista.
    Această apelare a metodei Sort a List&lt;T&gt; determină ca metoda CompareTo
    să fie apelată automat pentru obiectele Car din List.
    <pre> <code>
    private static void ListCars()
    {
        var cars = new List&lt;Car&gt;
        {
            { new Car() { Name = "car1", Color = "blue", Speed = 20}},
            { new Car() { Name = "car2", Color = "red", Speed = 50}},
            { new Car() { Name = "car3", Color = "green", Speed = 10}},
            { new Car() { Name = "car4", Color = "blue", Speed = 50}},
            { new Car() { Name = "car5", Color = "blue", Speed = 30}},
            { new Car() { Name = "car6", Color = "red", Speed = 60}},
            { new Car() { Name = "car7", Color = "green", Speed = 50}}
        };

        // Sort the cars by color alphabetically, and then by speed
        // in descending order.
        cars.Sort();

        // View all of the cars.
        foreach (Car thisCar in cars)
        {
            Console.Write(thisCar.Color.PadRight(5) + " ");
            Console.Write(thisCar.Speed.ToString() + " ");
            Console.Write(thisCar.Name);
            Console.WriteLine();
        }

        // Output:
        //  blue  50 car4
        //  blue  30 car5
        //  blue  20 car1
        //  green 50 car7
        //  green 10 car3
        //  red   60 car6
        //  red   50 car2
    }

    public class Car : IComparable&lt;Car&gt;
    {
        public string Name { get; set; }
        public int Speed { get; set; }
        public string Color { get; set; }

        public int CompareTo(Car other)
        {
            // A call to this method makes a single comparison that is
            // used for sorting.

            // Determine the relative order of the objects being compared.
            // Sort by color alphabetically, and then by speed in
            // descending order.

            // Compare the colors.
            int compare;
            compare = String.Compare(this.Color, other.Color, true);

            // If the colors are the same, compare the speeds.
            if (compare == 0)
            {
                compare = this.Speed.CompareTo(other.Speed);

                // Use descending order for speed.
                compare = -compare;
            }

            return compare;
        }
    }
</code></pre>

    <h3>5.2.8.7 Definirea unei colecții personalizate</h3>
    Puteți defini o colecție prin implementarea interfeței IEnumerable&lt;T&gt; sau IEnumerable.
    <br><br>
    Deși puteți defini o colecție personalizată, de obicei este mai bine să utilizați
    colecțiile incluse în .NET, care sunt descrise în tipurile de colecții în articolul
    anterior.
    <br><br>
    Următorul exemplu definește o clasă de colecție personalizată numită AllColors.
    Această clasă implementează interfața IEnumerable, care necesită implementarea
    metodei GetEnumerator.
    <br><br>
    Metoda GetEnumerator returnează o instanță a clasei ColorEnumerator. ColorEnumerator
    implementează interfața IEnumerator, care necesită implementarea proprietății Current,
    metodei MoveNext și metodei Reset.
    <pre> <code>
    private static void ListColors()
    {
        var colors = new AllColors();

        foreach (Color theColor in colors)
        {
            Console.Write(theColor.Name + " ");
        }
        Console.WriteLine();
        // Output: red blue green
    }

    // Collection class.
    public class AllColors : System.Collections.IEnumerable
    {
        Color[] _colors =
        {
            new Color() { Name = "red" },
            new Color() { Name = "blue" },
            new Color() { Name = "green" }
        };

        public System.Collections.IEnumerator GetEnumerator()
        {
            return new ColorEnumerator(_colors);

            // Instead of creating a custom enumerator, you could
            // use the GetEnumerator of the array.
            //return _colors.GetEnumerator();
        }

        // Custom enumerator.
        private class ColorEnumerator : System.Collections.IEnumerator
        {
            private Color[] _colors;
            private int _position = -1;

            public ColorEnumerator(Color[] colors)
            {
                _colors = colors;
            }

            object System.Collections.IEnumerator.Current
            {
                get
                {
                    return _colors[_position];
                }
            }

            bool System.Collections.IEnumerator.MoveNext()
            {
                _position++;
                return (_position &lt; _colors.Length);
            }

            void System.Collections.IEnumerator.Reset()
            {
                _position = -1;
            }
        }
    }

    // Element class.
    public class Color
    {
        public string Name { get; set; }
    }
</code></pre>

    <h3>5.2.8.8 Iteratori</h3>

    Un iterator este folosit pentru a efectua o iterație personalizată peste o colecție.
    Un iterator poate fi o metodă sau un accesoriu get. Un iterator utilizează o instrucțiune
    yield return pentru a returna fiecare element al colecției unul câte unul.
    <br><Br>
    Pentru a apela un iterator, se folosește o instrucțiune foreach. Fiecare iterație a
    buclei foreach apelează iteratorul. Când se ajunge la o instrucțiune yield return în
    iterator, se returnează o expresie, iar locația curentă în cod este reținută.
    Execuția este repornită de la acea locație data viitoare când iteratorul este apelat.
    <br><BR>
    <br><br>
    Exemplul următor utilizează o metodă iterator. Metoda iterator are
    o instrucțiune yield return care este în interiorul unei bucle for. În metoda
    ListEvenNumbers, fiecare iterație a corpului instrucțiunii foreach creează o apelare
    către metoda iterator, care trece la următoarea instrucțiune yield return.
    <pre> <code>
    private static void ListEvenNumbers()
    {
        foreach (int number in EvenSequence(5, 18))
        {
            Console.Write(number.ToString() + " ");
        }
        Console.WriteLine();
        // Output: 6 8 10 12 14 16 18
    }

    private static IEnumerable&lt;int&gt; EvenSequence(
        int firstNumber, int lastNumber)
    {
        // Yield even numbers in the range.
        for (var number = firstNumber; number &lt;= lastNumber; number++)
        {
            if (number % 2 == 0)
            {
                yield return number;
            }
        }
    }
 </code>   </pre>
    </p>


    <h1>5.9 Iteratori</h1>
    <p>
        Un iterator poate fi folosit pentru a parcurge colecții, cum ar fi liste și tablouri.
        <br><br>
        O metodă iterator sau un accesoriu get este folosit pentru a realiza o iterație
        personalizată peste o colecție. O metodă iterator utilizează instrucțiunea yield
        return pentru a returna fiecare element unul câte unul. Când se ajunge la o instrucțiune
        yield return, locația curentă în cod este reținută. Execuția este reluată de la acea
        locație data viitoare când este apelată funcția iterator.
        <br><br>
        Pentru a utiliza un iterator în codul client, se folosește o instrucțiune foreach
        sau o interogare LINQ.
        <br><br>
        În exemplul următor, prima iterație a buclei foreach determină ca execuția să
        continue în metoda iterator SomeNumbers până când este atinsă prima instrucțiune
        yield return. Această iterație returnează o valoare de 3, iar locația curentă în
        metoda iterator este reținută. La următoarea iterație a buclei, execuția în metoda
        iterator continuă de unde a rămas, oprindu-se din nou când ajunge la o instrucțiune
        yield return. Această iterație returnează o valoare de 5, iar locația curentă în metoda
        iterator este din nou reținută. Buclele se încheie când se ajunge la sfârșitul metodei
        iterator.
    <pre> <code>
    static void Main()
    {
        foreach (int number in SomeNumbers())
        {
            Console.Write(number.ToString() + " ");
        }
        // Output: 3 5 8
        Console.ReadKey();
    }

    public static System.Collections.IEnumerable SomeNumbers()
    {
        yield return 3;
        yield return 5;
        yield return 8;
    }
     </code>   </pre>

    Tipul de returnare al unei metode iterator sau a unui accesoriu
    get poate fi IEnumerable, IEnumerable&lt;T&gt;,
    IEnumerator sau IEnumerator&lt;T&gt;.
    <br><br>
    Se poate utiliza instrucțiunea yield break pentru a încheia iterația.
    <br><br>
    Notă
    <br>
    Pentru toate exemplele din acest subiect, cu excepția exemplului Simple Iterator, sunt necesare directivele
    using pentru namespace-urile System.Collections și System.Collections.Generic.

    </p>
    <h2>5.9.1 Iteratori simpli</h2>
    <p>
        Exemplul următor conține o singură instrucțiune yield return care se
        află într-un for loop. În metoda Main, fiecare iterație a corpului instrucțiunii
        foreach creează un apel la funcția iterator, care continuă la următoarea
        instrucțiune yield return.
    <pre> <code>
    static void Main()
    {
        foreach (int number in EvenSequence(5, 18))
        {
            Console.Write(number.ToString() + " ");
        }
        // Output: 6 8 10 12 14 16 18
        Console.ReadKey();
    }
        
    public static System.Collections.Generic.IEnumerable&lt;int&gt;
        EvenSequence(int firstNumber, int lastNumber)
    {
        // Yield even numbers in the range.
        for (int number = firstNumber; number &lt;= lastNumber; number++)
        {
            if (number % 2 == 0)
            {
                yield return number;
            }
        }
    }
    </code></pre>
    </p>

    <h2>5.9.2 Crearea unei clase de colecții</h2>
    <p>În exemplul următor, clasa DaysOfTheWeek implementează interfața IEnumerable,
        care necesită o metodă GetEnumerator. Compilatorul apelează implicit metoda
        GetEnumerator, care returnează un obiect de tipul IEnumerator.
        <br><br>
        Metoda GetEnumerator returnează fiecare șir de caractere pe rând folosind
        instrucțiunea yield return.
    <pre> <code>
    static void Main()
    {
        DaysOfTheWeek days = new DaysOfTheWeek();
    
        foreach (string day in days)
        {
            Console.Write(day + " ");
        }
        // Output: Sun Mon Tue Wed Thu Fri Sat
        Console.ReadKey();
    }
    
    public class DaysOfTheWeek : IEnumerable
    {
        private string[] days = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
    
        public IEnumerator GetEnumerator()
        {
            for (int index = 0; index &lt; days.Length; index++)
            {
                // Yield each day of the week.
                yield return days[index];
            }
        }
    }
</code></pre>
    ÎN exemplul următor se creează o clasă Zoo care conține o colecție de animale.
    <br><Br>
    Instrucțiunea foreach care face referire la instanța clasei (theZoo) apelează
    implicit metoda GetEnumerator. Instrucțiunile foreach care fac referire la
    proprietățile Birds și Mammals folosesc metoda iterator numită AnimalsForType.
    <pre> <code>
    static void Main()
    {
        Zoo theZoo = new Zoo();
    
        theZoo.AddMammal("Whale");
        theZoo.AddMammal("Rhinoceros");
        theZoo.AddBird("Penguin");
        theZoo.AddBird("Warbler");
    
        foreach (string name in theZoo)
        {
            Console.Write(name + " ");
        }
        Console.WriteLine();
        // Output: Whale Rhinoceros Penguin Warbler
    
        foreach (string name in theZoo.Birds)
        {
            Console.Write(name + " ");
        }
        Console.WriteLine();
        // Output: Penguin Warbler
    
        foreach (string name in theZoo.Mammals)
        {
            Console.Write(name + " ");
        }
        Console.WriteLine();
        // Output: Whale Rhinoceros
    
        Console.ReadKey();
    }
    
    public class Zoo : IEnumerable
    {
        // Private members.
        private List&lt;Animal&gt; animals = new List&lt;Animal&gt;();
    
        // Public methods.
        public void AddMammal(string name)
        {
            animals.Add(new Animal { Name = name, Type = Animal.TypeEnum.Mammal });
        }
    
        public void AddBird(string name)
        {
            animals.Add(new Animal { Name = name, Type = Animal.TypeEnum.Bird });
        }
    
        public IEnumerator GetEnumerator()
        {
            foreach (Animal theAnimal in animals)
            {
                yield return theAnimal.Name;
            }
        }
    
        // Public members.
        public IEnumerable Mammals
        {
            get { return AnimalsForType(Animal.TypeEnum.Mammal); }
        }
    
        public IEnumerable Birds
        {
            get { return AnimalsForType(Animal.TypeEnum.Bird); }
        }
    
        // Private methods.
        private IEnumerable AnimalsForType(Animal.TypeEnum type)
        {
            foreach (Animal theAnimal in animals)
            {
                if (theAnimal.Type == type)
                {
                    yield return theAnimal.Name;
                }
            }
        }
    
        // Private class.
        private class Animal
        {
            public enum TypeEnum { Bird, Mammal }
            public string Name { get; set; }
            public TypeEnum Type { get; set; }
        }
    }
</code></pre>
    </p>

    <h2>5.9.3 Utilizarea iteratorilor cu o listă generică</h2>
    <p>
        În exemplul următor, clasa generică Stack&lt;T&gt; implementează
        interfața generică IEnumerable&lt;T&gt;. Metoda Push
        atribuie valori unui tablou de tipul T.
        Metoda GetEnumerator returnează valorile din tablou folosind
        instrucțiunea yield return.
        <br><br>
        În plus față de metoda generică GetEnumerator, trebuie implementată
        și metoda GetEnumerator
        non-generică. Acest lucru se datorează faptului că IEnumerable&lt;T&gt;
        moștenește din IEnumerable.
        Implementarea non-generică se bazează pe implementarea generică.
        <br><br>
        Exemplul utilizează iteratori cu nume pentru a suporta diferite
        moduri de iterare prin aceeași
        colecție de date. Acești iteratori cu nume sunt proprietățile
        TopToBottom și BottomToTop și metoda
        TopN.
        <br><br>
        Proprietatea BottomToTop utilizează un iterator într-un accesoriu get.
    <pre><code>
    static void Main()
    {
        Stack&lt;int&gt; theStack = new Stack&lt;int&gt;();
            
        //  Add items to the stack.
             for (int number = 0; number &lt;= 9; number++)
            {
                theStack.Push(number);
            }
            
            // Retrieve items from the stack.
            // foreach is allowed because theStack implements IEnumerable&lt;int&gt;.
            foreach (int number in theStack)
            {
                Console.Write("{0} ", number);
            }
            Console.WriteLine();
            // Output: 9 8 7 6 5 4 3 2 1 0
            
            // foreach is allowed, because theStack.TopToBottom returns IEnumerable(Of Integer).
            foreach (int number in theStack.TopToBottom)
            {
                Console.Write("{0} ", number);
            }
            Console.WriteLine();
            // Output: 9 8 7 6 5 4 3 2 1 0
            
            foreach (int number in theStack.BottomToTop)
            {
                Console.Write("{0} ", number);
            }
            Console.WriteLine();
            // Output: 0 1 2 3 4 5 6 7 8 9
            
            foreach (int number in theStack.TopN(7))
            {
                Console.Write("{0} ", number);
            }
            Console.WriteLine();
            // Output: 9 8 7 6 5 4 3
            
            Console.ReadKey();
        }
            
        public class Stack&lt;T&gt; : IEnumerable&lt;T&gt;
        {
            private T[] values = new T[100];
            private int top = 0;
            
            public void Push(T t)
            {
                values[top] = t;
                top++;
            }
            public T Pop()
            {
                top--;
                return values[top];
            }
            
            // This method implements the GetEnumerator method. It allows
            // an instance of the class to be used in a foreach statement.
            public IEnumerator&lt;T&gt; GetEnumerator()
            {
                for (int index = top - 1; index &gt;= 0; index--)
                {
                    yield return values[index];
                }
            }
            
            IEnumerator IEnumerable.GetEnumerator()
            {
                return GetEnumerator();
            }
            
            public IEnumerable&lt;T&gt; TopToBottom
            {
                get { return this; }
            }
            
            public IEnumerable&lt;T&gt; BottomToTop
            {
                get
                {
                    for (int index = 0; index &lt;= top - 1; index++)
                    {
                        yield return values[index];
                    }
                }
            }
            
            public IEnumerable&lt;T&gt; TopN(int itemsFromTop)
            {
                // Return less than itemsFromTop if necessary.
                int startIndex = itemsFromTop &gt;= top ? 0 : top - itemsFromTop;
            
                for (int index = top - 1; index &gt;= startIndex; index--)
                {
                    yield return values[index];
                }
            }
            
    }
       </code> </pre>
    </p>

    <h2>5.9.4 Informații de sintaxă</h2>
    <p>
        Un iterator poate fi definit ca o metodă sau un accesoriu get.
        Un iterator nu poate fi definit într-un eveniment, constructor de instanță,
        constructor static sau într-un finalizator static.
        <br><br>
        Trebuie să existe o conversie implicită între tipul
        expresiei din instrucțiunea yield return și argumentul de
        tip pentru IEnumerable&lt;T&gt; returnat de iterator.
        <br><br>
        În C#, o metodă de iterator nu poate avea parametri in, ref sau out.
        <br><br>
        În C#, cuvântul cheie yield nu este rezervat și are semnificație
        specială doar atunci când este utilizat
        înaintea cuvintelor cheie return sau break.
    </p>

    <h2>5.9.5 Implementarea tehnică</h2>
    <p>
        Deși scrieți un iterator ca o metodă, compilatorul îl traduce
        într-o clasă imbricată care, în efect, este o mașină de stare.
        Această clasă urmărește poziția iteratorului atâta timp cât bucla
        foreach din codul client continuă.
        <br><br>
        Pentru a vedea ce face compilatorul, puteți utiliza instrumentul Ildasm.exe
        pentru a vizualiza codul de limbaj intermediar Microsoft generat pentru o metodă iterator.
        <br><br>
        Când creați un iterator pentru o clasă sau o structură, nu trebuie să implementați
        întregul interface IEnumerator. Când compilatorul detectează iteratorul, generează
        automat metodele Current, MoveNext și Dispose ale interfeței IEnumerator
        sau IEnumerator&lt;T&gt;.
        <br><br>
        La fiecare iterație succesivă a buclei foreach (sau apelului direct la
        IEnumerator.MoveNext), corpul următor al codului iteratorului este reluat
        după instrucțiunea yield return anterioară. Apoi continuă până la următoarea
        instrucțiune yield return până la sfârșitul corpului iteratorului sau până când
        este întâlnită o instrucțiune yield break.
        <br><br>
        Iteratoarele nu suportă metoda IEnumerator.Reset. Pentru a reitera de la început,
        trebuie să obțineți un nou iterator. Apelarea metodei Reset pe iteratorul returnat
        de o metodă iterator aruncă o excepție NotSupportedException.
    </p>

    <h2>5.9.6 Utilizarea iteratorilor</h2>
    <p>
        Iteratoarele permit menținerea simplității unui loop foreach
        atunci când este necesar să utilizați cod complex pentru a
        popula o secvență de liste. Acest lucru poate fi util atunci
        când doriți să faceți următoarele:
    <ul>
        <li>Modificați secvența listei după prima iterație a loop-ului foreach.</li>

        <li>Evitați încărcarea completă a unei liste mari înainte de prima iterație a
            unui loop foreach. Un exemplu ar fi o extragere paginată pentru a încărca un
            lot de rânduri de tabel. Un alt exemplu este metoda EnumerateFiles,
            care implementează iteratoare în .NET.</li>

        <li>Încapsulați construirea listei în iterator. În metoda iteratorului,
            puteți construi lista și apoi returna fiecare rezultat într-un loop.</li>
    </ul>
    </p>
</body>